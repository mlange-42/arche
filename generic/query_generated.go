package generic

// Code generated by go generate; DO NOT EDIT.

import (
	"github.com/mlange-42/arche/ecs"
)

//////////////////////////////////////////////////////////////////////////

// Filter0 is a helper for building [Query0] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter0()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter0().
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter0 filter

// NewFilter0 creates a generic Filter0 for zero components.
//
// See also [ecs.World.Query].
func NewFilter0() *Filter0 {
	f := Filter0(newFilter())
	return &f
}

// With adds components that are required, but not accessible via [Query0.Get].
//
// Create the required mask items with [T].
func (f *Filter0) With(mask ...Comp) *Filter0 {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter0) Without(mask ...Comp) *Filter0 {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter0) Exclusive() *Filter0 {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter0.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter0) WithRelation(comp Comp, target ...ecs.Entity) *Filter0 {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter0.WithRelation] was not called
//   - if the target was already set via [Filter0.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter0) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query0] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter0.WithRelation] was not called
//   - if the target was already set via [Filter0.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter0) Query(w *ecs.World, target ...ecs.Entity) Query0 {
	filter := f.Filter(w, target...)
	return Query0{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter0) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter0) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query0 is a generic query iterator for zero components.
//
// Create it with [NewFilter0] and [Filter0.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter0()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//	}
type Query0 struct {
	ecs.Query

	relation    ecs.ID
	hasRelation bool
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter0] was not prepared for relations
// using [Filter0.WithRelation].
func (q *Query0) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter1 is a helper for building [Query1] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter1[A]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter1[A]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter1[A any] filter

// NewFilter1 creates a generic Filter1 for one components.
//
// See also [ecs.World.Query].
func NewFilter1[A any]() *Filter1[A] {
	f := Filter1[A](newFilter(
		typeOf[A](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter1[A]) Optional(mask ...Comp) *Filter1[A] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query1.Get].
//
// Create the required mask items with [T].
func (f *Filter1[A]) With(mask ...Comp) *Filter1[A] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter1[A]) Without(mask ...Comp) *Filter1[A] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter1[A]) Exclusive() *Filter1[A] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter1.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter1[A]) WithRelation(comp Comp, target ...ecs.Entity) *Filter1[A] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter1.WithRelation] was not called
//   - if the target was already set via [Filter1.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter1[A]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query1] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter1.WithRelation] was not called
//   - if the target was already set via [Filter1.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter1[A]) Query(w *ecs.World, target ...ecs.Entity) Query1[A] {
	filter := f.Filter(w, target...)
	return Query1[A]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter1[A]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter1[A]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query1 is a generic query iterator for one components.
//
// Create it with [NewFilter1] and [Filter1.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter1[A]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a := query.Get()
//	}
type Query1[A any] struct {
	ecs.Query
	id0         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query1[A]) Get() *A {
	return (*A)(q.Query.Get(q.id0))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter1] was not prepared for relations
// using [Filter1.WithRelation].
func (q *Query1[A]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter2 is a helper for building [Query2] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter2[A, B]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter2[A, B]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter2[A any, B any] filter

// NewFilter2 creates a generic Filter2 for two components.
//
// See also [ecs.World.Query].
func NewFilter2[A any, B any]() *Filter2[A, B] {
	f := Filter2[A, B](newFilter(
		typeOf[A](),
		typeOf[B](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter2[A, B]) Optional(mask ...Comp) *Filter2[A, B] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query2.Get].
//
// Create the required mask items with [T].
func (f *Filter2[A, B]) With(mask ...Comp) *Filter2[A, B] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter2[A, B]) Without(mask ...Comp) *Filter2[A, B] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter2[A, B]) Exclusive() *Filter2[A, B] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter2.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter2[A, B]) WithRelation(comp Comp, target ...ecs.Entity) *Filter2[A, B] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter2.WithRelation] was not called
//   - if the target was already set via [Filter2.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter2[A, B]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query2] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter2.WithRelation] was not called
//   - if the target was already set via [Filter2.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter2[A, B]) Query(w *ecs.World, target ...ecs.Entity) Query2[A, B] {
	filter := f.Filter(w, target...)
	return Query2[A, B]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter2[A, B]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter2[A, B]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query2 is a generic query iterator for two components.
//
// Create it with [NewFilter2] and [Filter2.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter2[A, B]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b := query.Get()
//	}
type Query2[A any, B any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query2[A, B]) Get() (*A, *B) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter2] was not prepared for relations
// using [Filter2.WithRelation].
func (q *Query2[A, B]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter3 is a helper for building [Query3] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter3[A, B, C]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter3[A, B, C]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter3[A any, B any, C any] filter

// NewFilter3 creates a generic Filter3 for three components.
//
// See also [ecs.World.Query].
func NewFilter3[A any, B any, C any]() *Filter3[A, B, C] {
	f := Filter3[A, B, C](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter3[A, B, C]) Optional(mask ...Comp) *Filter3[A, B, C] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query3.Get].
//
// Create the required mask items with [T].
func (f *Filter3[A, B, C]) With(mask ...Comp) *Filter3[A, B, C] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter3[A, B, C]) Without(mask ...Comp) *Filter3[A, B, C] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter3[A, B, C]) Exclusive() *Filter3[A, B, C] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter3.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter3[A, B, C]) WithRelation(comp Comp, target ...ecs.Entity) *Filter3[A, B, C] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter3.WithRelation] was not called
//   - if the target was already set via [Filter3.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter3[A, B, C]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query3] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter3.WithRelation] was not called
//   - if the target was already set via [Filter3.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter3[A, B, C]) Query(w *ecs.World, target ...ecs.Entity) Query3[A, B, C] {
	filter := f.Filter(w, target...)
	return Query3[A, B, C]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter3[A, B, C]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter3[A, B, C]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query3 is a generic query iterator for three components.
//
// Create it with [NewFilter3] and [Filter3.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter3[A, B, C]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c := query.Get()
//	}
type Query3[A any, B any, C any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query3[A, B, C]) Get() (*A, *B, *C) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter3] was not prepared for relations
// using [Filter3.WithRelation].
func (q *Query3[A, B, C]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter4 is a helper for building [Query4] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter4[A, B, C, D]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter4[A, B, C, D]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter4[A any, B any, C any, D any] filter

// NewFilter4 creates a generic Filter4 for four components.
//
// See also [ecs.World.Query].
func NewFilter4[A any, B any, C any, D any]() *Filter4[A, B, C, D] {
	f := Filter4[A, B, C, D](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter4[A, B, C, D]) Optional(mask ...Comp) *Filter4[A, B, C, D] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query4.Get].
//
// Create the required mask items with [T].
func (f *Filter4[A, B, C, D]) With(mask ...Comp) *Filter4[A, B, C, D] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter4[A, B, C, D]) Without(mask ...Comp) *Filter4[A, B, C, D] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter4[A, B, C, D]) Exclusive() *Filter4[A, B, C, D] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter4.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter4[A, B, C, D]) WithRelation(comp Comp, target ...ecs.Entity) *Filter4[A, B, C, D] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter4.WithRelation] was not called
//   - if the target was already set via [Filter4.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter4[A, B, C, D]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query4] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter4.WithRelation] was not called
//   - if the target was already set via [Filter4.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter4[A, B, C, D]) Query(w *ecs.World, target ...ecs.Entity) Query4[A, B, C, D] {
	filter := f.Filter(w, target...)
	return Query4[A, B, C, D]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter4[A, B, C, D]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter4[A, B, C, D]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query4 is a generic query iterator for four components.
//
// Create it with [NewFilter4] and [Filter4.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter4[A, B, C, D]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d := query.Get()
//	}
type Query4[A any, B any, C any, D any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query4[A, B, C, D]) Get() (*A, *B, *C, *D) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter4] was not prepared for relations
// using [Filter4.WithRelation].
func (q *Query4[A, B, C, D]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter5 is a helper for building [Query5] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter5[A, B, C, D, E]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter5[A, B, C, D, E]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter5[A any, B any, C any, D any, E any] filter

// NewFilter5 creates a generic Filter5 for five components.
//
// See also [ecs.World.Query].
func NewFilter5[A any, B any, C any, D any, E any]() *Filter5[A, B, C, D, E] {
	f := Filter5[A, B, C, D, E](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter5[A, B, C, D, E]) Optional(mask ...Comp) *Filter5[A, B, C, D, E] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query5.Get].
//
// Create the required mask items with [T].
func (f *Filter5[A, B, C, D, E]) With(mask ...Comp) *Filter5[A, B, C, D, E] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter5[A, B, C, D, E]) Without(mask ...Comp) *Filter5[A, B, C, D, E] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter5[A, B, C, D, E]) Exclusive() *Filter5[A, B, C, D, E] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter5.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter5[A, B, C, D, E]) WithRelation(comp Comp, target ...ecs.Entity) *Filter5[A, B, C, D, E] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter5.WithRelation] was not called
//   - if the target was already set via [Filter5.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter5[A, B, C, D, E]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query5] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter5.WithRelation] was not called
//   - if the target was already set via [Filter5.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter5[A, B, C, D, E]) Query(w *ecs.World, target ...ecs.Entity) Query5[A, B, C, D, E] {
	filter := f.Filter(w, target...)
	return Query5[A, B, C, D, E]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter5[A, B, C, D, E]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter5[A, B, C, D, E]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query5 is a generic query iterator for five components.
//
// Create it with [NewFilter5] and [Filter5.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter5[A, B, C, D, E]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e := query.Get()
//	}
type Query5[A any, B any, C any, D any, E any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query5[A, B, C, D, E]) Get() (*A, *B, *C, *D, *E) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter5] was not prepared for relations
// using [Filter5.WithRelation].
func (q *Query5[A, B, C, D, E]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter6 is a helper for building [Query6] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter6[A, B, C, D, E, F]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter6[A, B, C, D, E, F]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter6[A any, B any, C any, D any, E any, F any] filter

// NewFilter6 creates a generic Filter6 for six components.
//
// See also [ecs.World.Query].
func NewFilter6[A any, B any, C any, D any, E any, F any]() *Filter6[A, B, C, D, E, F] {
	f := Filter6[A, B, C, D, E, F](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter6[A, B, C, D, E, F]) Optional(mask ...Comp) *Filter6[A, B, C, D, E, F] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query6.Get].
//
// Create the required mask items with [T].
func (f *Filter6[A, B, C, D, E, F]) With(mask ...Comp) *Filter6[A, B, C, D, E, F] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter6[A, B, C, D, E, F]) Without(mask ...Comp) *Filter6[A, B, C, D, E, F] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter6[A, B, C, D, E, F]) Exclusive() *Filter6[A, B, C, D, E, F] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter6.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter6[A, B, C, D, E, F]) WithRelation(comp Comp, target ...ecs.Entity) *Filter6[A, B, C, D, E, F] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter6.WithRelation] was not called
//   - if the target was already set via [Filter6.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter6[A, B, C, D, E, F]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query6] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter6.WithRelation] was not called
//   - if the target was already set via [Filter6.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter6[A, B, C, D, E, F]) Query(w *ecs.World, target ...ecs.Entity) Query6[A, B, C, D, E, F] {
	filter := f.Filter(w, target...)
	return Query6[A, B, C, D, E, F]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter6[A, B, C, D, E, F]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter6[A, B, C, D, E, F]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query6 is a generic query iterator for six components.
//
// Create it with [NewFilter6] and [Filter6.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter6[A, B, C, D, E, F]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f := query.Get()
//	}
type Query6[A any, B any, C any, D any, E any, F any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query6[A, B, C, D, E, F]) Get() (*A, *B, *C, *D, *E, *F) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter6] was not prepared for relations
// using [Filter6.WithRelation].
func (q *Query6[A, B, C, D, E, F]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter7 is a helper for building [Query7] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter7[A, B, C, D, E, F, G]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter7[A, B, C, D, E, F, G]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter7[A any, B any, C any, D any, E any, F any, G any] filter

// NewFilter7 creates a generic Filter7 for seven components.
//
// See also [ecs.World.Query].
func NewFilter7[A any, B any, C any, D any, E any, F any, G any]() *Filter7[A, B, C, D, E, F, G] {
	f := Filter7[A, B, C, D, E, F, G](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
		typeOf[G](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter7[A, B, C, D, E, F, G]) Optional(mask ...Comp) *Filter7[A, B, C, D, E, F, G] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query7.Get].
//
// Create the required mask items with [T].
func (f *Filter7[A, B, C, D, E, F, G]) With(mask ...Comp) *Filter7[A, B, C, D, E, F, G] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter7[A, B, C, D, E, F, G]) Without(mask ...Comp) *Filter7[A, B, C, D, E, F, G] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter7[A, B, C, D, E, F, G]) Exclusive() *Filter7[A, B, C, D, E, F, G] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter7.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter7[A, B, C, D, E, F, G]) WithRelation(comp Comp, target ...ecs.Entity) *Filter7[A, B, C, D, E, F, G] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter7.WithRelation] was not called
//   - if the target was already set via [Filter7.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter7[A, B, C, D, E, F, G]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query7] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter7.WithRelation] was not called
//   - if the target was already set via [Filter7.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter7[A, B, C, D, E, F, G]) Query(w *ecs.World, target ...ecs.Entity) Query7[A, B, C, D, E, F, G] {
	filter := f.Filter(w, target...)
	return Query7[A, B, C, D, E, F, G]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
		id6:         f.compiled.Ids[6],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter7[A, B, C, D, E, F, G]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter7[A, B, C, D, E, F, G]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query7 is a generic query iterator for seven components.
//
// Create it with [NewFilter7] and [Filter7.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter7[A, B, C, D, E, F, G]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g := query.Get()
//	}
type Query7[A any, B any, C any, D any, E any, F any, G any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query7[A, B, C, D, E, F, G]) Get() (*A, *B, *C, *D, *E, *F, *G) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter7] was not prepared for relations
// using [Filter7.WithRelation].
func (q *Query7[A, B, C, D, E, F, G]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter8 is a helper for building [Query8] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter8[A, B, C, D, E, F, G, H]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter8[A, B, C, D, E, F, G, H]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter8[A any, B any, C any, D any, E any, F any, G any, H any] filter

// NewFilter8 creates a generic Filter8 for eight components.
//
// See also [ecs.World.Query].
func NewFilter8[A any, B any, C any, D any, E any, F any, G any, H any]() *Filter8[A, B, C, D, E, F, G, H] {
	f := Filter8[A, B, C, D, E, F, G, H](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
		typeOf[G](),
		typeOf[H](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter8[A, B, C, D, E, F, G, H]) Optional(mask ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query8.Get].
//
// Create the required mask items with [T].
func (f *Filter8[A, B, C, D, E, F, G, H]) With(mask ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter8[A, B, C, D, E, F, G, H]) Without(mask ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter8[A, B, C, D, E, F, G, H]) Exclusive() *Filter8[A, B, C, D, E, F, G, H] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter8.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter8[A, B, C, D, E, F, G, H]) WithRelation(comp Comp, target ...ecs.Entity) *Filter8[A, B, C, D, E, F, G, H] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter8.WithRelation] was not called
//   - if the target was already set via [Filter8.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter8[A, B, C, D, E, F, G, H]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query8] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter8.WithRelation] was not called
//   - if the target was already set via [Filter8.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter8[A, B, C, D, E, F, G, H]) Query(w *ecs.World, target ...ecs.Entity) Query8[A, B, C, D, E, F, G, H] {
	filter := f.Filter(w, target...)
	return Query8[A, B, C, D, E, F, G, H]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
		id6:         f.compiled.Ids[6],
		id7:         f.compiled.Ids[7],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter8[A, B, C, D, E, F, G, H]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter8[A, B, C, D, E, F, G, H]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query8 is a generic query iterator for eight components.
//
// Create it with [NewFilter8] and [Filter8.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter8[A, B, C, D, E, F, G, H]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g, h := query.Get()
//	}
type Query8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Get() (*A, *B, *C, *D, *E, *F, *G, *H) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6)),
		(*H)(q.Query.Get(q.id7))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter8] was not prepared for relations
// using [Filter8.WithRelation].
func (q *Query8[A, B, C, D, E, F, G, H]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter9 is a helper for building [Query9] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter9[A, B, C, D, E, F, G, H, I]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter9[A, B, C, D, E, F, G, H, I]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter9[A any, B any, C any, D any, E any, F any, G any, H any, I any] filter

// NewFilter9 creates a generic Filter9 for nine components.
//
// See also [ecs.World.Query].
func NewFilter9[A any, B any, C any, D any, E any, F any, G any, H any, I any]() *Filter9[A, B, C, D, E, F, G, H, I] {
	f := Filter9[A, B, C, D, E, F, G, H, I](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
		typeOf[G](),
		typeOf[H](),
		typeOf[I](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Optional(mask ...Comp) *Filter9[A, B, C, D, E, F, G, H, I] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query9.Get].
//
// Create the required mask items with [T].
func (f *Filter9[A, B, C, D, E, F, G, H, I]) With(mask ...Comp) *Filter9[A, B, C, D, E, F, G, H, I] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Without(mask ...Comp) *Filter9[A, B, C, D, E, F, G, H, I] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Exclusive() *Filter9[A, B, C, D, E, F, G, H, I] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter9.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter9[A, B, C, D, E, F, G, H, I]) WithRelation(comp Comp, target ...ecs.Entity) *Filter9[A, B, C, D, E, F, G, H, I] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter9.WithRelation] was not called
//   - if the target was already set via [Filter9.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query9] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter9.WithRelation] was not called
//   - if the target was already set via [Filter9.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Query(w *ecs.World, target ...ecs.Entity) Query9[A, B, C, D, E, F, G, H, I] {
	filter := f.Filter(w, target...)
	return Query9[A, B, C, D, E, F, G, H, I]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
		id6:         f.compiled.Ids[6],
		id7:         f.compiled.Ids[7],
		id8:         f.compiled.Ids[8],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter9[A, B, C, D, E, F, G, H, I]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query9 is a generic query iterator for nine components.
//
// Create it with [NewFilter9] and [Filter9.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter9[A, B, C, D, E, F, G, H, I]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g, h, i := query.Get()
//	}
type Query9[A any, B any, C any, D any, E any, F any, G any, H any, I any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query9[A, B, C, D, E, F, G, H, I]) Get() (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6)),
		(*H)(q.Query.Get(q.id7)),
		(*I)(q.Query.Get(q.id8))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter9] was not prepared for relations
// using [Filter9.WithRelation].
func (q *Query9[A, B, C, D, E, F, G, H, I]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter10 is a helper for building [Query10] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter10[A, B, C, D, E, F, G, H, I, J]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter10[A, B, C, D, E, F, G, H, I, J]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any] filter

// NewFilter10 creates a generic Filter10 for ten components.
//
// See also [ecs.World.Query].
func NewFilter10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any]() *Filter10[A, B, C, D, E, F, G, H, I, J] {
	f := Filter10[A, B, C, D, E, F, G, H, I, J](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
		typeOf[G](),
		typeOf[H](),
		typeOf[I](),
		typeOf[J](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Optional(mask ...Comp) *Filter10[A, B, C, D, E, F, G, H, I, J] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query10.Get].
//
// Create the required mask items with [T].
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) With(mask ...Comp) *Filter10[A, B, C, D, E, F, G, H, I, J] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Without(mask ...Comp) *Filter10[A, B, C, D, E, F, G, H, I, J] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Exclusive() *Filter10[A, B, C, D, E, F, G, H, I, J] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter10.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) WithRelation(comp Comp, target ...ecs.Entity) *Filter10[A, B, C, D, E, F, G, H, I, J] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter10.WithRelation] was not called
//   - if the target was already set via [Filter10.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query10] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter10.WithRelation] was not called
//   - if the target was already set via [Filter10.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Query(w *ecs.World, target ...ecs.Entity) Query10[A, B, C, D, E, F, G, H, I, J] {
	filter := f.Filter(w, target...)
	return Query10[A, B, C, D, E, F, G, H, I, J]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
		id6:         f.compiled.Ids[6],
		id7:         f.compiled.Ids[7],
		id8:         f.compiled.Ids[8],
		id9:         f.compiled.Ids[9],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter10[A, B, C, D, E, F, G, H, I, J]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query10 is a generic query iterator for ten components.
//
// Create it with [NewFilter10] and [Filter10.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter10[A, B, C, D, E, F, G, H, I, J]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g, h, i, j := query.Get()
//	}
type Query10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	id9         ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query10[A, B, C, D, E, F, G, H, I, J]) Get() (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6)),
		(*H)(q.Query.Get(q.id7)),
		(*I)(q.Query.Get(q.id8)),
		(*J)(q.Query.Get(q.id9))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter10] was not prepared for relations
// using [Filter10.WithRelation].
func (q *Query10[A, B, C, D, E, F, G, H, I, J]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter11 is a helper for building [Query11] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter11[A, B, C, D, E, F, G, H, I, J, K]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter11[A, B, C, D, E, F, G, H, I, J, K]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any] filter

// NewFilter11 creates a generic Filter11 for eleven components.
//
// See also [ecs.World.Query].
func NewFilter11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any]() *Filter11[A, B, C, D, E, F, G, H, I, J, K] {
	f := Filter11[A, B, C, D, E, F, G, H, I, J, K](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
		typeOf[G](),
		typeOf[H](),
		typeOf[I](),
		typeOf[J](),
		typeOf[K](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Optional(mask ...Comp) *Filter11[A, B, C, D, E, F, G, H, I, J, K] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query11.Get].
//
// Create the required mask items with [T].
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) With(mask ...Comp) *Filter11[A, B, C, D, E, F, G, H, I, J, K] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Without(mask ...Comp) *Filter11[A, B, C, D, E, F, G, H, I, J, K] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Exclusive() *Filter11[A, B, C, D, E, F, G, H, I, J, K] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter11.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) WithRelation(comp Comp, target ...ecs.Entity) *Filter11[A, B, C, D, E, F, G, H, I, J, K] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter11.WithRelation] was not called
//   - if the target was already set via [Filter11.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query11] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter11.WithRelation] was not called
//   - if the target was already set via [Filter11.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Query(w *ecs.World, target ...ecs.Entity) Query11[A, B, C, D, E, F, G, H, I, J, K] {
	filter := f.Filter(w, target...)
	return Query11[A, B, C, D, E, F, G, H, I, J, K]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
		id6:         f.compiled.Ids[6],
		id7:         f.compiled.Ids[7],
		id8:         f.compiled.Ids[8],
		id9:         f.compiled.Ids[9],
		id10:        f.compiled.Ids[10],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter11[A, B, C, D, E, F, G, H, I, J, K]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query11 is a generic query iterator for eleven components.
//
// Create it with [NewFilter11] and [Filter11.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter11[A, B, C, D, E, F, G, H, I, J, K]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g, h, i, j, k := query.Get()
//	}
type Query11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	id9         ecs.ID
	id10        ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query11[A, B, C, D, E, F, G, H, I, J, K]) Get() (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6)),
		(*H)(q.Query.Get(q.id7)),
		(*I)(q.Query.Get(q.id8)),
		(*J)(q.Query.Get(q.id9)),
		(*K)(q.Query.Get(q.id10))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter11] was not prepared for relations
// using [Filter11.WithRelation].
func (q *Query11[A, B, C, D, E, F, G, H, I, J, K]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}

//////////////////////////////////////////////////////////////////////////

// Filter12 is a helper for building [Query12] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter12[A, B, C, D, E, F, G, H, I, J, K, L]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter12[A, B, C, D, E, F, G, H, I, J, K, L]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any] filter

// NewFilter12 creates a generic Filter12 for twelve components.
//
// See also [ecs.World.Query].
func NewFilter12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any]() *Filter12[A, B, C, D, E, F, G, H, I, J, K, L] {
	f := Filter12[A, B, C, D, E, F, G, H, I, J, K, L](newFilter(
		typeOf[A](),
		typeOf[B](),
		typeOf[C](),
		typeOf[D](),
		typeOf[E](),
		typeOf[F](),
		typeOf[G](),
		typeOf[H](),
		typeOf[I](),
		typeOf[J](),
		typeOf[K](),
		typeOf[L](),
	))
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Optional(mask ...Comp) *Filter12[A, B, C, D, E, F, G, H, I, J, K, L] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.optional = append(f.optional, mask...)
	f.compiled.Reset()
	return f
}

// With adds components that are required, but not accessible via [Query12.Get].
//
// Create the required mask items with [T].
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) With(mask ...Comp) *Filter12[A, B, C, D, E, F, G, H, I, J, K, L] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.include = append(f.include, mask...)
	f.compiled.Reset()
	return f
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Without(mask ...Comp) *Filter12[A, B, C, D, E, F, G, H, I, J, K, L] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if f.exclusive {
		panic("filter is already exclusive")
	}
	f.exclude = append(f.exclude, mask...)
	f.compiled.Reset()
	return f
}

// Exclusive makes the filter exclusive in the sense that the component composition is matched exactly,
// and no other components are allowed.
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Exclusive() *Filter12[A, B, C, D, E, F, G, H, I, J, K, L] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	if len(f.exclude) > 0 {
		panic("filter already excludes some components")
	}
	f.exclusive = true
	return f
}

// WithRelation sets the filter's [ecs.Relation] component and optionally
// restricts the query to entities that have the given relation target.
//
// Use without the optional argument to specify the relation target in [Filter12.Query].
// If the optional argument is provided, the filter's relation target is set permanently.
//
// Create the required component ID with [T].
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) WithRelation(comp Comp, target ...ecs.Entity) *Filter12[A, B, C, D, E, F, G, H, I, J, K, L] {
	if f.compiled.locked {
		panic("can't modify a registered filter")
	}
	f.targetType = comp
	if len(target) > 0 {
		f.target = target[0]
		f.hasTarget = true
	}
	f.compiled.Reset()
	return f
}

// Filter builds an [ecs.Filter], with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter12.WithRelation] was not called
//   - if the target was already set via [Filter12.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Filter(w *ecs.World, target ...ecs.Entity) ecs.Filter {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)

	filter := f.compiled.filter
	if len(target) > 0 {
		if f.compiled.locked {
			panic("can't change relation target on a cached query")
		}
		if f.hasTarget {
			panic("can't change relation target on a query with fixed target")
		}
		f.compiled.relationFilter.Filter = &f.compiled.maskFilter
		f.compiled.relationFilter.Target = target[0]
		filter = &f.compiled.relationFilter
	}

	return filter
}

// Query builds a [Query12] query for iteration, with an optional relation target.
//
// A relation target can't be used:
//   - if [Filter12.WithRelation] was not called
//   - if the target was already set via [Filter12.WithRelation]
//   - if the filter is registered for caching
//
// Panics in these cases.
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Query(w *ecs.World, target ...ecs.Entity) Query12[A, B, C, D, E, F, G, H, I, J, K, L] {
	filter := f.Filter(w, target...)
	return Query12[A, B, C, D, E, F, G, H, I, J, K, L]{
		Query:       w.Query(filter),
		relation:    f.compiled.Relation,
		hasRelation: f.compiled.HasRelation,
		id0:         f.compiled.Ids[0],
		id1:         f.compiled.Ids[1],
		id2:         f.compiled.Ids[2],
		id3:         f.compiled.Ids[3],
		id4:         f.compiled.Ids[4],
		id5:         f.compiled.Ids[5],
		id6:         f.compiled.Ids[6],
		id7:         f.compiled.Ids[7],
		id8:         f.compiled.Ids[8],
		id9:         f.compiled.Ids[9],
		id10:        f.compiled.Ids[10],
		id11:        f.compiled.Ids[11],
	}
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Register(w *ecs.World) {
	f.compiled.Compile(w, f.include, f.optional, f.exclude, f.exclusive, f.targetType, f.target, f.hasTarget)
	f.compiled.Register(w)
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (f *Filter12[A, B, C, D, E, F, G, H, I, J, K, L]) Unregister(w *ecs.World) {
	f.compiled.Unregister(w)
}

// Query12 is a generic query iterator for twelve components.
//
// Create it with [NewFilter12] and [Filter12.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter12[A, B, C, D, E, F, G, H, I, J, K, L]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g, h, i, j, k, l := query.Get()
//	}
type Query12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any] struct {
	ecs.Query
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	id9         ecs.ID
	id10        ecs.ID
	id11        ecs.ID
	relation    ecs.ID
	hasRelation bool
}

// Get returns all queried components for the current query iterator position.
//
// ⚠️ Important: The obtained pointers should not be stored persistently!
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query12[A, B, C, D, E, F, G, H, I, J, K, L]) Get() (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6)),
		(*H)(q.Query.Get(q.id7)),
		(*I)(q.Query.Get(q.id8)),
		(*J)(q.Query.Get(q.id9)),
		(*K)(q.Query.Get(q.id10)),
		(*L)(q.Query.Get(q.id11))
}

// Relation returns the target entity for the query's relation.
//
// Panics if the entity does not have the given component, or if the component is not an [ecs.Relation].
// Panics if the underlying [Filter12] was not prepared for relations
// using [Filter12.WithRelation].
func (q *Query12[A, B, C, D, E, F, G, H, I, J, K, L]) Relation() ecs.Entity {
	if !q.hasRelation {
		panic("query has no relation")
	}
	return q.Query.Relation(q.relation)
}
