package generic

// Code generated by go generate; DO NOT EDIT.

import (
	"github.com/mlange-42/arche/ecs"
)

//////////////////////////////////////////////////////////////////////////

// Filter0 is a helper for building [Query0] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter0()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter0().
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter0 filter

// NewFilter0 creates a generic Filter0 for zero components.
//
// See also [ecs.World.Query].
func NewFilter0() *Filter0 {
	f := Filter0(filter{
		include: []Comp{},
	})
	return &f
}

// With adds components that are required, but not accessible via [Query0.Get].
//
// Create the required mask items with [T].
func (q *Filter0) With(mask ...Comp) *Filter0 {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter0) Without(mask ...Comp) *Filter0 {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter0) WithRelation(comp Comp, target ecs.Entity) *Filter0 {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query0] query for iteration.
func (q *Filter0) Query(w *ecs.World) Query0 {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query0{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter0.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter0.Query].
func (q *Filter0) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter0) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter0) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query0 is a generic query iterator for zero components.
//
// Create it with [NewFilter0] and [Filter0.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter0()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//	}
type Query0 struct {
	ecs.Query

	target int8
}

// Relation returns the target entity for the query's relation.
func (q *Query0) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter1 is a helper for building [Query1] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter1[A]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter1[A]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter1[A any] filter

// NewFilter1 creates a generic Filter1 for one components.
//
// See also [ecs.World.Query].
func NewFilter1[A any]() *Filter1[A] {
	f := Filter1[A](filter{
		include: []Comp{
			typeOf[A](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter1[A]) Optional(mask ...Comp) *Filter1[A] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query1.Get].
//
// Create the required mask items with [T].
func (q *Filter1[A]) With(mask ...Comp) *Filter1[A] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter1[A]) Without(mask ...Comp) *Filter1[A] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter1[A]) WithRelation(comp Comp, target ecs.Entity) *Filter1[A] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query1] query for iteration.
func (q *Filter1[A]) Query(w *ecs.World) Query1[A] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query1[A]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter1.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter1.Query].
func (q *Filter1[A]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter1[A]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter1[A]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query1 is a generic query iterator for one components.
//
// Create it with [NewFilter1] and [Filter1.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter1[A]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a := query.Get()
//	}
type Query1[A any] struct {
	ecs.Query
	id0    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query1[A]) Get() *A {
	return (*A)(q.Query.Get(q.id0))
}

// Relation returns the target entity for the query's relation.
func (q *Query1[A]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter2 is a helper for building [Query2] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter2[A, B]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter2[A, B]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter2[A any, B any] filter

// NewFilter2 creates a generic Filter2 for two components.
//
// See also [ecs.World.Query].
func NewFilter2[A any, B any]() *Filter2[A, B] {
	f := Filter2[A, B](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter2[A, B]) Optional(mask ...Comp) *Filter2[A, B] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query2.Get].
//
// Create the required mask items with [T].
func (q *Filter2[A, B]) With(mask ...Comp) *Filter2[A, B] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter2[A, B]) Without(mask ...Comp) *Filter2[A, B] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter2[A, B]) WithRelation(comp Comp, target ecs.Entity) *Filter2[A, B] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query2] query for iteration.
func (q *Filter2[A, B]) Query(w *ecs.World) Query2[A, B] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query2[A, B]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter2.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter2.Query].
func (q *Filter2[A, B]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter2[A, B]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter2[A, B]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query2 is a generic query iterator for two components.
//
// Create it with [NewFilter2] and [Filter2.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter2[A, B]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b := query.Get()
//	}
type Query2[A any, B any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query2[A, B]) Get() (*A, *B) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1))
}

// Relation returns the target entity for the query's relation.
func (q *Query2[A, B]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter3 is a helper for building [Query3] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter3[A, B, C]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter3[A, B, C]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter3[A any, B any, C any] filter

// NewFilter3 creates a generic Filter3 for three components.
//
// See also [ecs.World.Query].
func NewFilter3[A any, B any, C any]() *Filter3[A, B, C] {
	f := Filter3[A, B, C](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
			typeOf[C](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter3[A, B, C]) Optional(mask ...Comp) *Filter3[A, B, C] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query3.Get].
//
// Create the required mask items with [T].
func (q *Filter3[A, B, C]) With(mask ...Comp) *Filter3[A, B, C] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter3[A, B, C]) Without(mask ...Comp) *Filter3[A, B, C] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter3[A, B, C]) WithRelation(comp Comp, target ecs.Entity) *Filter3[A, B, C] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query3] query for iteration.
func (q *Filter3[A, B, C]) Query(w *ecs.World) Query3[A, B, C] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query3[A, B, C]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
		id2:    q.compiled.Ids[2],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter3.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter3.Query].
func (q *Filter3[A, B, C]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter3[A, B, C]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter3[A, B, C]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query3 is a generic query iterator for three components.
//
// Create it with [NewFilter3] and [Filter3.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter3[A, B, C]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c := query.Get()
//	}
type Query3[A any, B any, C any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	id2    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query3[A, B, C]) Get() (*A, *B, *C) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2))
}

// Relation returns the target entity for the query's relation.
func (q *Query3[A, B, C]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter4 is a helper for building [Query4] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter4[A, B, C, D]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter4[A, B, C, D]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter4[A any, B any, C any, D any] filter

// NewFilter4 creates a generic Filter4 for four components.
//
// See also [ecs.World.Query].
func NewFilter4[A any, B any, C any, D any]() *Filter4[A, B, C, D] {
	f := Filter4[A, B, C, D](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
			typeOf[C](),
			typeOf[D](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter4[A, B, C, D]) Optional(mask ...Comp) *Filter4[A, B, C, D] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query4.Get].
//
// Create the required mask items with [T].
func (q *Filter4[A, B, C, D]) With(mask ...Comp) *Filter4[A, B, C, D] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter4[A, B, C, D]) Without(mask ...Comp) *Filter4[A, B, C, D] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter4[A, B, C, D]) WithRelation(comp Comp, target ecs.Entity) *Filter4[A, B, C, D] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query4] query for iteration.
func (q *Filter4[A, B, C, D]) Query(w *ecs.World) Query4[A, B, C, D] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query4[A, B, C, D]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
		id2:    q.compiled.Ids[2],
		id3:    q.compiled.Ids[3],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter4.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter4.Query].
func (q *Filter4[A, B, C, D]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter4[A, B, C, D]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter4[A, B, C, D]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query4 is a generic query iterator for four components.
//
// Create it with [NewFilter4] and [Filter4.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter4[A, B, C, D]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d := query.Get()
//	}
type Query4[A any, B any, C any, D any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	id2    ecs.ID
	id3    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query4[A, B, C, D]) Get() (*A, *B, *C, *D) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3))
}

// Relation returns the target entity for the query's relation.
func (q *Query4[A, B, C, D]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter5 is a helper for building [Query5] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter5[A, B, C, D, E]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter5[A, B, C, D, E]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter5[A any, B any, C any, D any, E any] filter

// NewFilter5 creates a generic Filter5 for five components.
//
// See also [ecs.World.Query].
func NewFilter5[A any, B any, C any, D any, E any]() *Filter5[A, B, C, D, E] {
	f := Filter5[A, B, C, D, E](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
			typeOf[C](),
			typeOf[D](),
			typeOf[E](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter5[A, B, C, D, E]) Optional(mask ...Comp) *Filter5[A, B, C, D, E] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query5.Get].
//
// Create the required mask items with [T].
func (q *Filter5[A, B, C, D, E]) With(mask ...Comp) *Filter5[A, B, C, D, E] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter5[A, B, C, D, E]) Without(mask ...Comp) *Filter5[A, B, C, D, E] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter5[A, B, C, D, E]) WithRelation(comp Comp, target ecs.Entity) *Filter5[A, B, C, D, E] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query5] query for iteration.
func (q *Filter5[A, B, C, D, E]) Query(w *ecs.World) Query5[A, B, C, D, E] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query5[A, B, C, D, E]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
		id2:    q.compiled.Ids[2],
		id3:    q.compiled.Ids[3],
		id4:    q.compiled.Ids[4],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter5.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter5.Query].
func (q *Filter5[A, B, C, D, E]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter5[A, B, C, D, E]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter5[A, B, C, D, E]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query5 is a generic query iterator for five components.
//
// Create it with [NewFilter5] and [Filter5.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter5[A, B, C, D, E]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e := query.Get()
//	}
type Query5[A any, B any, C any, D any, E any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	id2    ecs.ID
	id3    ecs.ID
	id4    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query5[A, B, C, D, E]) Get() (*A, *B, *C, *D, *E) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4))
}

// Relation returns the target entity for the query's relation.
func (q *Query5[A, B, C, D, E]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter6 is a helper for building [Query6] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter6[A, B, C, D, E, F]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter6[A, B, C, D, E, F]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter6[A any, B any, C any, D any, E any, F any] filter

// NewFilter6 creates a generic Filter6 for six components.
//
// See also [ecs.World.Query].
func NewFilter6[A any, B any, C any, D any, E any, F any]() *Filter6[A, B, C, D, E, F] {
	f := Filter6[A, B, C, D, E, F](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
			typeOf[C](),
			typeOf[D](),
			typeOf[E](),
			typeOf[F](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter6[A, B, C, D, E, F]) Optional(mask ...Comp) *Filter6[A, B, C, D, E, F] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query6.Get].
//
// Create the required mask items with [T].
func (q *Filter6[A, B, C, D, E, F]) With(mask ...Comp) *Filter6[A, B, C, D, E, F] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter6[A, B, C, D, E, F]) Without(mask ...Comp) *Filter6[A, B, C, D, E, F] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter6[A, B, C, D, E, F]) WithRelation(comp Comp, target ecs.Entity) *Filter6[A, B, C, D, E, F] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query6] query for iteration.
func (q *Filter6[A, B, C, D, E, F]) Query(w *ecs.World) Query6[A, B, C, D, E, F] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query6[A, B, C, D, E, F]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
		id2:    q.compiled.Ids[2],
		id3:    q.compiled.Ids[3],
		id4:    q.compiled.Ids[4],
		id5:    q.compiled.Ids[5],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter6.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter6.Query].
func (q *Filter6[A, B, C, D, E, F]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter6[A, B, C, D, E, F]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter6[A, B, C, D, E, F]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query6 is a generic query iterator for six components.
//
// Create it with [NewFilter6] and [Filter6.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter6[A, B, C, D, E, F]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f := query.Get()
//	}
type Query6[A any, B any, C any, D any, E any, F any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	id2    ecs.ID
	id3    ecs.ID
	id4    ecs.ID
	id5    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query6[A, B, C, D, E, F]) Get() (*A, *B, *C, *D, *E, *F) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5))
}

// Relation returns the target entity for the query's relation.
func (q *Query6[A, B, C, D, E, F]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter7 is a helper for building [Query7] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter7[A, B, C, D, E, F, G]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter7[A, B, C, D, E, F, G]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter7[A any, B any, C any, D any, E any, F any, G any] filter

// NewFilter7 creates a generic Filter7 for seven components.
//
// See also [ecs.World.Query].
func NewFilter7[A any, B any, C any, D any, E any, F any, G any]() *Filter7[A, B, C, D, E, F, G] {
	f := Filter7[A, B, C, D, E, F, G](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
			typeOf[C](),
			typeOf[D](),
			typeOf[E](),
			typeOf[F](),
			typeOf[G](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter7[A, B, C, D, E, F, G]) Optional(mask ...Comp) *Filter7[A, B, C, D, E, F, G] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query7.Get].
//
// Create the required mask items with [T].
func (q *Filter7[A, B, C, D, E, F, G]) With(mask ...Comp) *Filter7[A, B, C, D, E, F, G] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter7[A, B, C, D, E, F, G]) Without(mask ...Comp) *Filter7[A, B, C, D, E, F, G] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter7[A, B, C, D, E, F, G]) WithRelation(comp Comp, target ecs.Entity) *Filter7[A, B, C, D, E, F, G] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query7] query for iteration.
func (q *Filter7[A, B, C, D, E, F, G]) Query(w *ecs.World) Query7[A, B, C, D, E, F, G] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query7[A, B, C, D, E, F, G]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
		id2:    q.compiled.Ids[2],
		id3:    q.compiled.Ids[3],
		id4:    q.compiled.Ids[4],
		id5:    q.compiled.Ids[5],
		id6:    q.compiled.Ids[6],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter7.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter7.Query].
func (q *Filter7[A, B, C, D, E, F, G]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter7[A, B, C, D, E, F, G]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter7[A, B, C, D, E, F, G]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query7 is a generic query iterator for seven components.
//
// Create it with [NewFilter7] and [Filter7.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter7[A, B, C, D, E, F, G]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g := query.Get()
//	}
type Query7[A any, B any, C any, D any, E any, F any, G any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	id2    ecs.ID
	id3    ecs.ID
	id4    ecs.ID
	id5    ecs.ID
	id6    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query7[A, B, C, D, E, F, G]) Get() (*A, *B, *C, *D, *E, *F, *G) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6))
}

// Relation returns the target entity for the query's relation.
func (q *Query7[A, B, C, D, E, F, G]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}

//////////////////////////////////////////////////////////////////////////

// Filter8 is a helper for building [Query8] query iterators.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter8[A, B, C, D, E, F, G, H]()
//	query := filter.Query(&world)
//
//	complexFilter :=
//		NewFilter8[A, B, C, D, E, F, G, H]().
//			Optional(T[A]()).
//			With(T2[V, W]()...).
//			Without(T3[X, Y, Z]()...).
type Filter8[A any, B any, C any, D any, E any, F any, G any, H any] filter

// NewFilter8 creates a generic Filter8 for eight components.
//
// See also [ecs.World.Query].
func NewFilter8[A any, B any, C any, D any, E any, F any, G any, H any]() *Filter8[A, B, C, D, E, F, G, H] {
	f := Filter8[A, B, C, D, E, F, G, H](filter{
		include: []Comp{
			typeOf[A](),
			typeOf[B](),
			typeOf[C](),
			typeOf[D](),
			typeOf[E](),
			typeOf[F](),
			typeOf[G](),
			typeOf[H](),
		},
	})
	return &f
}

// Optional makes some of the query's components optional.
//
// Create the required mask items with [T].
//
// Only affects component types that were specified in the query.
func (q *Filter8[A, B, C, D, E, F, G, H]) Optional(mask ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.optional = append(q.optional, mask...)
	q.compiled.Reset()
	return q
}

// With adds components that are required, but not accessible via [Query8.Get].
//
// Create the required mask items with [T].
func (q *Filter8[A, B, C, D, E, F, G, H]) With(mask ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.include = append(q.include, mask...)
	q.compiled.Reset()
	return q
}

// Without excludes entities with any of the given components from the query.
//
// Create the required mask items with [T].
func (q *Filter8[A, B, C, D, E, F, G, H]) Without(mask ...Comp) *Filter8[A, B, C, D, E, F, G, H] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.exclude = append(q.exclude, mask...)
	q.compiled.Reset()
	return q
}

// WithRelation restricts the query to entities that have the given relation.
//
// Create the required component ID with [T].
func (q *Filter8[A, B, C, D, E, F, G, H]) WithRelation(comp Comp, target ecs.Entity) *Filter8[A, B, C, D, E, F, G, H] {
	if q.compiled.locked {
		panic("can't modify a registered filter")
	}
	q.targetType = comp
	q.target = target
	q.compiled.Reset()
	return q
}

// Query builds a [Query8] query for iteration.
func (q *Filter8[A, B, C, D, E, F, G, H]) Query(w *ecs.World) Query8[A, B, C, D, E, F, G, H] {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return Query8[A, B, C, D, E, F, G, H]{
		Query:  w.Query(q.compiled.filter),
		target: q.compiled.TargetID,
		id0:    q.compiled.Ids[0],
		id1:    q.compiled.Ids[1],
		id2:    q.compiled.Ids[2],
		id3:    q.compiled.Ids[3],
		id4:    q.compiled.Ids[4],
		id5:    q.compiled.Ids[5],
		id6:    q.compiled.Ids[6],
		id7:    q.compiled.Ids[7],
	}
}

// Filter generates and return the [ecs.Filter] used after [Filter8.Query].
//
// Can be passed to [ecs.World.Query].
// For the intended generic use, however, generate a generic query with [Filter8.Query].
func (q *Filter8[A, B, C, D, E, F, G, H]) Filter(w *ecs.World) ecs.MaskFilter {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	return q.compiled.maskFilter
}

// Register the filter for caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter8[A, B, C, D, E, F, G, H]) Register(w *ecs.World) {
	q.compiled.Compile(w, q.include, q.optional, q.exclude, q.targetType, q.target)
	q.compiled.cachedFilter = w.Cache().Register(q.compiled.filter)
	q.compiled.filter = &q.compiled.cachedFilter
	q.compiled.locked = true
}

// Unregister the filter from caching.
//
// See [ecs.Cache] for details on filter caching.
func (q *Filter8[A, B, C, D, E, F, G, H]) Unregister(w *ecs.World) {
	if cf, ok := q.compiled.filter.(*ecs.CachedFilter); ok {
		q.compiled.filter = w.Cache().Unregister(cf)
	} else {
		panic("can't unregister a filter that is not cached")
	}
	q.compiled.locked = false
}

// Query8 is a generic query iterator for eight components.
//
// Create it with [NewFilter8] and [Filter8.Query].
//
// Also has all methods of [ecs.Query].
//
// # Example
//
//	world := ecs.NewWorld()
//
//	filter := NewFilter8[A, B, C, D, E, F, G, H]()
//	query := filter.Query(&world)
//	for query.Next() {
//		entity = query.Entity()
//		a, b, c, d, e, f, g, h := query.Get()
//	}
type Query8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	ecs.Query
	id0    ecs.ID
	id1    ecs.ID
	id2    ecs.ID
	id3    ecs.ID
	id4    ecs.ID
	id5    ecs.ID
	id6    ecs.ID
	id7    ecs.ID
	target int8
}

// Get returns all queried components for the current query iterator position.
//
// Use [ecs.Query.Entity] to get the current Entity.
func (q *Query8[A, B, C, D, E, F, G, H]) Get() (*A, *B, *C, *D, *E, *F, *G, *H) {
	return (*A)(q.Query.Get(q.id0)),
		(*B)(q.Query.Get(q.id1)),
		(*C)(q.Query.Get(q.id2)),
		(*D)(q.Query.Get(q.id3)),
		(*E)(q.Query.Get(q.id4)),
		(*F)(q.Query.Get(q.id5)),
		(*G)(q.Query.Get(q.id6)),
		(*H)(q.Query.Get(q.id7))
}

// Relation returns the target entity for the query's relation.
func (q *Query8[A, B, C, D, E, F, G, H]) Relation() ecs.Entity {
	if q.target < 0 {
		panic("query has no relation")
	}
	return q.Query.Relation(ecs.ID(q.target))
}
