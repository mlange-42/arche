package generic

// Code generated by go generate; DO NOT EDIT.

import (
	"github.com/mlange-42/arche/ecs"
)

//////////////////////////////////////////////////////////////////////////

// Map1 is a helper for mapping one components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap1[A](&world)
//
//	entity := mapper.NewEntity()
//	a := mapper.Get(entity)
type Map1[A any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
}

// NewMap1 creates a new Map1 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap1[A any](w *ecs.World, relation ...Comp) Map1[A] {
	m := Map1[A]{
		world: w,
		id0:   ecs.ComponentID[A](w),
	}
	m.ids = []ecs.ID{m.id0}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map1's components for the given entity.
//
// See [Map1.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map1[A]) Get(entity ecs.Entity) *A {
	return (*A)(m.world.Get(entity, m.id0))
}

// GetUnchecked all the Map1's components for the given entity.
//
// GetUnchecked is an optimized version of [Map1.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map1[A]) GetUnchecked(entity ecs.Entity) *A {
	return (*A)(m.world.GetUnchecked(entity, m.id0))
}

// New creates a new [ecs.Entity] with the Map1's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map1[A]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map1's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [Map1.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map1[A]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map1's components.
// It returns a [Query1] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map1.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map1[A]) NewBatchQ(count int, target ...ecs.Entity) Query1[A] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query1[A]{
		Query: query,
		id0:   m.id0,
	}
}

// NewWith creates a new [ecs.Entity] with the Map1's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map1[A]) NewWith(a *A, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a})
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a}).WithRelation(m.relation).New(target[0])
}

// Add the Map1's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map1[A]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map1 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map1's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map1[A]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map1 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map1's components to multiple entities and returns a query over them
// and the newly added Map1's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map1[A]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query1[A] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map1 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query1[A]{
		Query: query,
		id0:   m.id0,
	}
}

// Assign the Map1's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map1[A]) Assign(entity ecs.Entity, a *A) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
	)
}

// Remove the Map1's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map1[A]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map1 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map1's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map1[A]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map1 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map1's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map1's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map1[A]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map1 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map1's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map1[A]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map2 is a helper for mapping two components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap2[A, B](&world)
//
//	entity := mapper.NewEntity()
//	a, b := mapper.Get(entity)
type Map2[A any, B any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
}

// NewMap2 creates a new Map2 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap2[A any, B any](w *ecs.World, relation ...Comp) Map2[A, B] {
	m := Map2[A, B]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map2's components for the given entity.
//
// See [Map2.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map2[A, B]) Get(entity ecs.Entity) (*A, *B) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1))
}

// GetUnchecked all the Map2's components for the given entity.
//
// GetUnchecked is an optimized version of [Map2.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map2[A, B]) GetUnchecked(entity ecs.Entity) (*A, *B) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1))
}

// New creates a new [ecs.Entity] with the Map2's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map2[A, B]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map2's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [Map2.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map2[A, B]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map2's components.
// It returns a [Query2] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map2.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map2[A, B]) NewBatchQ(count int, target ...ecs.Entity) Query2[A, B] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query2[A, B]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
	}
}

// NewWith creates a new [ecs.Entity] with the Map2's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map2[A, B]) NewWith(a *A, b *B, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map2's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map2[A, B]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map2 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map2's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map2[A, B]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map2 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map2's components to multiple entities and returns a query over them
// and the newly added Map2's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map2[A, B]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query2[A, B] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map2 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query2[A, B]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
	}
}

// Assign the Map2's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map2[A, B]) Assign(entity ecs.Entity, a *A, b *B) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
	)
}

// Remove the Map2's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map2[A, B]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map2 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map2's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map2[A, B]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map2 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map2's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map2's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map2[A, B]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map2 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map2's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map2[A, B]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map3 is a helper for mapping three components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap3[A, B, C](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c := mapper.Get(entity)
type Map3[A any, B any, C any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
}

// NewMap3 creates a new Map3 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap3[A any, B any, C any](w *ecs.World, relation ...Comp) Map3[A, B, C] {
	m := Map3[A, B, C]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map3's components for the given entity.
//
// See [Map3.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map3[A, B, C]) Get(entity ecs.Entity) (*A, *B, *C) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2))
}

// GetUnchecked all the Map3's components for the given entity.
//
// GetUnchecked is an optimized version of [Map3.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map3[A, B, C]) GetUnchecked(entity ecs.Entity) (*A, *B, *C) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2))
}

// New creates a new [ecs.Entity] with the Map3's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map3[A, B, C]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map3's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [Map3.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map3[A, B, C]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map3's components.
// It returns a [Query3] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map3.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map3[A, B, C]) NewBatchQ(count int, target ...ecs.Entity) Query3[A, B, C] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query3[A, B, C]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
	}
}

// NewWith creates a new [ecs.Entity] with the Map3's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map3[A, B, C]) NewWith(a *A, b *B, c *C, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map3's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map3[A, B, C]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map3 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map3's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map3[A, B, C]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map3 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map3's components to multiple entities and returns a query over them
// and the newly added Map3's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map3[A, B, C]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query3[A, B, C] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map3 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query3[A, B, C]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
	}
}

// Assign the Map3's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map3[A, B, C]) Assign(entity ecs.Entity, a *A, b *B, c *C) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
	)
}

// Remove the Map3's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map3[A, B, C]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map3 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map3's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map3[A, B, C]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map3 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map3's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map3's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map3[A, B, C]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map3 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map3's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map3[A, B, C]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map4 is a helper for mapping four components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap4[A, B, C, D](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d := mapper.Get(entity)
type Map4[A any, B any, C any, D any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
}

// NewMap4 creates a new Map4 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap4[A any, B any, C any, D any](w *ecs.World, relation ...Comp) Map4[A, B, C, D] {
	m := Map4[A, B, C, D]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map4's components for the given entity.
//
// See [Map4.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map4[A, B, C, D]) Get(entity ecs.Entity) (*A, *B, *C, *D) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3))
}

// GetUnchecked all the Map4's components for the given entity.
//
// GetUnchecked is an optimized version of [Map4.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map4[A, B, C, D]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3))
}

// New creates a new [ecs.Entity] with the Map4's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map4[A, B, C, D]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map4's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [Map4.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map4[A, B, C, D]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map4's components.
// It returns a [Query4] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map4.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map4[A, B, C, D]) NewBatchQ(count int, target ...ecs.Entity) Query4[A, B, C, D] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query4[A, B, C, D]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
	}
}

// NewWith creates a new [ecs.Entity] with the Map4's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map4[A, B, C, D]) NewWith(a *A, b *B, c *C, d *D, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map4's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map4[A, B, C, D]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map4 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map4's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map4[A, B, C, D]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map4 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map4's components to multiple entities and returns a query over them
// and the newly added Map4's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map4[A, B, C, D]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query4[A, B, C, D] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map4 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query4[A, B, C, D]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
	}
}

// Assign the Map4's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map4[A, B, C, D]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
	)
}

// Remove the Map4's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map4[A, B, C, D]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map4 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map4's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map4[A, B, C, D]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map4 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map4's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map4's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map4[A, B, C, D]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map4 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map4's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map4[A, B, C, D]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map5 is a helper for mapping five components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap5[A, B, C, D, E](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e := mapper.Get(entity)
type Map5[A any, B any, C any, D any, E any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
}

// NewMap5 creates a new Map5 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap5[A any, B any, C any, D any, E any](w *ecs.World, relation ...Comp) Map5[A, B, C, D, E] {
	m := Map5[A, B, C, D, E]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map5's components for the given entity.
//
// See [Map5.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map5[A, B, C, D, E]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4))
}

// GetUnchecked all the Map5's components for the given entity.
//
// GetUnchecked is an optimized version of [Map5.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map5[A, B, C, D, E]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4))
}

// New creates a new [ecs.Entity] with the Map5's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map5[A, B, C, D, E]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map5's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [Map5.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map5[A, B, C, D, E]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map5's components.
// It returns a [Query5] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map5.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map5[A, B, C, D, E]) NewBatchQ(count int, target ...ecs.Entity) Query5[A, B, C, D, E] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query5[A, B, C, D, E]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
	}
}

// NewWith creates a new [ecs.Entity] with the Map5's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map5[A, B, C, D, E]) NewWith(a *A, b *B, c *C, d *D, e *E, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map5's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map5[A, B, C, D, E]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map5 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map5's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map5[A, B, C, D, E]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map5 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map5's components to multiple entities and returns a query over them
// and the newly added Map5's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map5[A, B, C, D, E]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query5[A, B, C, D, E] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map5 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query5[A, B, C, D, E]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
	}
}

// Assign the Map5's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map5[A, B, C, D, E]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
	)
}

// Remove the Map5's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map5[A, B, C, D, E]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map5 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map5's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map5[A, B, C, D, E]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map5 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map5's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map5's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map5[A, B, C, D, E]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map5 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map5's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map5[A, B, C, D, E]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map6 is a helper for mapping six components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap6[A, B, C, D, E, F](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f := mapper.Get(entity)
type Map6[A any, B any, C any, D any, E any, F any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
}

// NewMap6 creates a new Map6 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap6[A any, B any, C any, D any, E any, F any](w *ecs.World, relation ...Comp) Map6[A, B, C, D, E, F] {
	m := Map6[A, B, C, D, E, F]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map6's components for the given entity.
//
// See [Map6.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map6[A, B, C, D, E, F]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5))
}

// GetUnchecked all the Map6's components for the given entity.
//
// GetUnchecked is an optimized version of [Map6.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map6[A, B, C, D, E, F]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5))
}

// New creates a new [ecs.Entity] with the Map6's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map6[A, B, C, D, E, F]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map6's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [Map6.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map6[A, B, C, D, E, F]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map6's components.
// It returns a [Query6] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map6.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map6[A, B, C, D, E, F]) NewBatchQ(count int, target ...ecs.Entity) Query6[A, B, C, D, E, F] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query6[A, B, C, D, E, F]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
	}
}

// NewWith creates a new [ecs.Entity] with the Map6's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map6[A, B, C, D, E, F]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map6's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map6[A, B, C, D, E, F]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map6 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map6's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map6[A, B, C, D, E, F]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map6 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map6's components to multiple entities and returns a query over them
// and the newly added Map6's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map6[A, B, C, D, E, F]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query6[A, B, C, D, E, F] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map6 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query6[A, B, C, D, E, F]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
	}
}

// Assign the Map6's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map6[A, B, C, D, E, F]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
	)
}

// Remove the Map6's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map6[A, B, C, D, E, F]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map6 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map6's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map6[A, B, C, D, E, F]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map6 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map6's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map6's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map6[A, B, C, D, E, F]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map6 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map6's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map6[A, B, C, D, E, F]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map7 is a helper for mapping seven components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap7[A, B, C, D, E, F, G](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f, g := mapper.Get(entity)
type Map7[A any, B any, C any, D any, E any, F any, G any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
}

// NewMap7 creates a new Map7 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap7[A any, B any, C any, D any, E any, F any, G any](w *ecs.World, relation ...Comp) Map7[A, B, C, D, E, F, G] {
	m := Map7[A, B, C, D, E, F, G]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
		id6:   ecs.ComponentID[G](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5, m.id6}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map7's components for the given entity.
//
// See [Map7.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map7[A, B, C, D, E, F, G]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6))
}

// GetUnchecked all the Map7's components for the given entity.
//
// GetUnchecked is an optimized version of [Map7.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map7[A, B, C, D, E, F, G]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6))
}

// New creates a new [ecs.Entity] with the Map7's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map7[A, B, C, D, E, F, G]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map7's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [Map7.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map7[A, B, C, D, E, F, G]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map7's components.
// It returns a [Query7] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map7.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map7[A, B, C, D, E, F, G]) NewBatchQ(count int, target ...ecs.Entity) Query7[A, B, C, D, E, F, G] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query7[A, B, C, D, E, F, G]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
	}
}

// NewWith creates a new [ecs.Entity] with the Map7's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map7[A, B, C, D, E, F, G]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, g *G, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
			ecs.Component{ID: m.id6, Comp: g},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map7's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map7[A, B, C, D, E, F, G]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map7 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map7's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map7[A, B, C, D, E, F, G]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map7 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map7's components to multiple entities and returns a query over them
// and the newly added Map7's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map7[A, B, C, D, E, F, G]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query7[A, B, C, D, E, F, G] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map7 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query7[A, B, C, D, E, F, G]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
	}
}

// Assign the Map7's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map7[A, B, C, D, E, F, G]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
	)
}

// Remove the Map7's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map7[A, B, C, D, E, F, G]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map7 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map7's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map7[A, B, C, D, E, F, G]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map7 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map7's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map7's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map7[A, B, C, D, E, F, G]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map7 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map7's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map7[A, B, C, D, E, F, G]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map8 is a helper for mapping eight components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap8[A, B, C, D, E, F, G, H](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f, g, h := mapper.Get(entity)
type Map8[A any, B any, C any, D any, E any, F any, G any, H any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
}

// NewMap8 creates a new Map8 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap8[A any, B any, C any, D any, E any, F any, G any, H any](w *ecs.World, relation ...Comp) Map8[A, B, C, D, E, F, G, H] {
	m := Map8[A, B, C, D, E, F, G, H]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
		id6:   ecs.ComponentID[G](w),
		id7:   ecs.ComponentID[H](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5, m.id6, m.id7}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map8's components for the given entity.
//
// See [Map8.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map8[A, B, C, D, E, F, G, H]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7))
}

// GetUnchecked all the Map8's components for the given entity.
//
// GetUnchecked is an optimized version of [Map8.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map8[A, B, C, D, E, F, G, H]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7))
}

// New creates a new [ecs.Entity] with the Map8's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map8[A, B, C, D, E, F, G, H]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map8's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [Map8.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map8's components.
// It returns a [Query8] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map8.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map8[A, B, C, D, E, F, G, H]) NewBatchQ(count int, target ...ecs.Entity) Query8[A, B, C, D, E, F, G, H] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query8[A, B, C, D, E, F, G, H]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
	}
}

// NewWith creates a new [ecs.Entity] with the Map8's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map8[A, B, C, D, E, F, G, H]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
			ecs.Component{ID: m.id6, Comp: g},
			ecs.Component{ID: m.id7, Comp: h},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map8's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map8[A, B, C, D, E, F, G, H]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map8 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map8's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map8 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map8's components to multiple entities and returns a query over them
// and the newly added Map8's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map8[A, B, C, D, E, F, G, H]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query8[A, B, C, D, E, F, G, H] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map8 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query8[A, B, C, D, E, F, G, H]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
	}
}

// Assign the Map8's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map8[A, B, C, D, E, F, G, H]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
	)
}

// Remove the Map8's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map8[A, B, C, D, E, F, G, H]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map8 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map8's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map8[A, B, C, D, E, F, G, H]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map8 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map8's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map8's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map8[A, B, C, D, E, F, G, H]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map8 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map8's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map8[A, B, C, D, E, F, G, H]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map9 is a helper for mapping nine components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap9[A, B, C, D, E, F, G, H, I](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f, g, h, i := mapper.Get(entity)
type Map9[A any, B any, C any, D any, E any, F any, G any, H any, I any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
}

// NewMap9 creates a new Map9 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap9[A any, B any, C any, D any, E any, F any, G any, H any, I any](w *ecs.World, relation ...Comp) Map9[A, B, C, D, E, F, G, H, I] {
	m := Map9[A, B, C, D, E, F, G, H, I]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
		id6:   ecs.ComponentID[G](w),
		id7:   ecs.ComponentID[H](w),
		id8:   ecs.ComponentID[I](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5, m.id6, m.id7, m.id8}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map9's components for the given entity.
//
// See [Map9.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map9[A, B, C, D, E, F, G, H, I]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8))
}

// GetUnchecked all the Map9's components for the given entity.
//
// GetUnchecked is an optimized version of [Map9.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map9[A, B, C, D, E, F, G, H, I]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8))
}

// New creates a new [ecs.Entity] with the Map9's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map9[A, B, C, D, E, F, G, H, I]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map9's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [Map9.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map9's components.
// It returns a [Query9] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map9.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewBatchQ(count int, target ...ecs.Entity) Query9[A, B, C, D, E, F, G, H, I] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query9[A, B, C, D, E, F, G, H, I]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
	}
}

// NewWith creates a new [ecs.Entity] with the Map9's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map9[A, B, C, D, E, F, G, H, I]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
			ecs.Component{ID: m.id6, Comp: g},
			ecs.Component{ID: m.id7, Comp: h},
			ecs.Component{ID: m.id8, Comp: i},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map9's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map9[A, B, C, D, E, F, G, H, I]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map9 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map9's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map9 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map9's components to multiple entities and returns a query over them
// and the newly added Map9's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map9[A, B, C, D, E, F, G, H, I]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query9[A, B, C, D, E, F, G, H, I] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map9 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query9[A, B, C, D, E, F, G, H, I]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
	}
}

// Assign the Map9's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map9[A, B, C, D, E, F, G, H, I]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
	)
}

// Remove the Map9's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map9[A, B, C, D, E, F, G, H, I]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map9 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map9's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map9[A, B, C, D, E, F, G, H, I]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map9 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map9's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map9's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map9[A, B, C, D, E, F, G, H, I]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map9 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map9's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map9[A, B, C, D, E, F, G, H, I]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map10 is a helper for mapping ten components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap10[A, B, C, D, E, F, G, H, I, J](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f, g, h, i, j := mapper.Get(entity)
type Map10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	id9         ecs.ID
}

// NewMap10 creates a new Map10 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap10[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any](w *ecs.World, relation ...Comp) Map10[A, B, C, D, E, F, G, H, I, J] {
	m := Map10[A, B, C, D, E, F, G, H, I, J]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
		id6:   ecs.ComponentID[G](w),
		id7:   ecs.ComponentID[H](w),
		id8:   ecs.ComponentID[I](w),
		id9:   ecs.ComponentID[J](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5, m.id6, m.id7, m.id8, m.id9}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map10's components for the given entity.
//
// See [Map10.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8)),
		(*J)(m.world.GetUnchecked(entity, m.id9))
}

// GetUnchecked all the Map10's components for the given entity.
//
// GetUnchecked is an optimized version of [Map10.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8)),
		(*J)(m.world.GetUnchecked(entity, m.id9))
}

// New creates a new [ecs.Entity] with the Map10's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map10's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [Map10.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map10's components.
// It returns a [Query10] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map10.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewBatchQ(count int, target ...ecs.Entity) Query10[A, B, C, D, E, F, G, H, I, J] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query10[A, B, C, D, E, F, G, H, I, J]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
		id9:   m.id9,
	}
}

// NewWith creates a new [ecs.Entity] with the Map10's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
			ecs.Component{ID: m.id6, Comp: g},
			ecs.Component{ID: m.id7, Comp: h},
			ecs.Component{ID: m.id8, Comp: i},
			ecs.Component{ID: m.id9, Comp: j},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
		ecs.Component{ID: m.id9, Comp: j},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map10's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map10 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map10's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map10 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map10's components to multiple entities and returns a query over them
// and the newly added Map10's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query10[A, B, C, D, E, F, G, H, I, J] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map10 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query10[A, B, C, D, E, F, G, H, I, J]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
		id9:   m.id9,
	}
}

// Assign the Map10's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
		ecs.Component{ID: m.id9, Comp: j},
	)
}

// Remove the Map10's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map10 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map10's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map10 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map10's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map10's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map10 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map10's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map10[A, B, C, D, E, F, G, H, I, J]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map11 is a helper for mapping eleven components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap11[A, B, C, D, E, F, G, H, I, J, K](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f, g, h, i, j, k := mapper.Get(entity)
type Map11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	id9         ecs.ID
	id10        ecs.ID
}

// NewMap11 creates a new Map11 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap11[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any](w *ecs.World, relation ...Comp) Map11[A, B, C, D, E, F, G, H, I, J, K] {
	m := Map11[A, B, C, D, E, F, G, H, I, J, K]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
		id6:   ecs.ComponentID[G](w),
		id7:   ecs.ComponentID[H](w),
		id8:   ecs.ComponentID[I](w),
		id9:   ecs.ComponentID[J](w),
		id10:  ecs.ComponentID[K](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5, m.id6, m.id7, m.id8, m.id9, m.id10}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map11's components for the given entity.
//
// See [Map11.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8)),
		(*J)(m.world.GetUnchecked(entity, m.id9)),
		(*K)(m.world.GetUnchecked(entity, m.id10))
}

// GetUnchecked all the Map11's components for the given entity.
//
// GetUnchecked is an optimized version of [Map11.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8)),
		(*J)(m.world.GetUnchecked(entity, m.id9)),
		(*K)(m.world.GetUnchecked(entity, m.id10))
}

// New creates a new [ecs.Entity] with the Map11's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map11's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [Map11.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map11's components.
// It returns a [Query11] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map11.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewBatchQ(count int, target ...ecs.Entity) Query11[A, B, C, D, E, F, G, H, I, J, K] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query11[A, B, C, D, E, F, G, H, I, J, K]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
		id9:   m.id9,
		id10:  m.id10,
	}
}

// NewWith creates a new [ecs.Entity] with the Map11's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
			ecs.Component{ID: m.id6, Comp: g},
			ecs.Component{ID: m.id7, Comp: h},
			ecs.Component{ID: m.id8, Comp: i},
			ecs.Component{ID: m.id9, Comp: j},
			ecs.Component{ID: m.id10, Comp: k},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
		ecs.Component{ID: m.id9, Comp: j},
		ecs.Component{ID: m.id10, Comp: k},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map11's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map11 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map11's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map11 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map11's components to multiple entities and returns a query over them
// and the newly added Map11's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query11[A, B, C, D, E, F, G, H, I, J, K] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map11 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query11[A, B, C, D, E, F, G, H, I, J, K]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
		id9:   m.id9,
		id10:  m.id10,
	}
}

// Assign the Map11's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
		ecs.Component{ID: m.id9, Comp: j},
		ecs.Component{ID: m.id10, Comp: k},
	)
}

// Remove the Map11's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map11 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map11's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map11 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map11's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map11's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map11 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map11's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map11[A, B, C, D, E, F, G, H, I, J, K]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}

//////////////////////////////////////////////////////////////////////////

// Map12 is a helper for mapping twelve components.
//
// # Example
//
//	world := ecs.NewWorld()
//
//	mapper := NewMap12[A, B, C, D, E, F, G, H, I, J, K, L](&world)
//
//	entity := mapper.NewEntity()
//	a, b, c, d, e, f, g, h, i, j, k, l := mapper.Get(entity)
type Map12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any] struct {
	world       *ecs.World
	mask        ecs.Mask
	relation    ecs.ID
	hasRelation bool
	ids         []ecs.ID
	id0         ecs.ID
	id1         ecs.ID
	id2         ecs.ID
	id3         ecs.ID
	id4         ecs.ID
	id5         ecs.ID
	id6         ecs.ID
	id7         ecs.ID
	id8         ecs.ID
	id9         ecs.ID
	id10        ecs.ID
	id11        ecs.ID
}

// NewMap12 creates a new Map12 object.
//
// The optional argument can be used to set an [ecs.Relation] component type.
func NewMap12[A any, B any, C any, D any, E any, F any, G any, H any, I any, J any, K any, L any](w *ecs.World, relation ...Comp) Map12[A, B, C, D, E, F, G, H, I, J, K, L] {
	m := Map12[A, B, C, D, E, F, G, H, I, J, K, L]{
		world: w,
		id0:   ecs.ComponentID[A](w),
		id1:   ecs.ComponentID[B](w),
		id2:   ecs.ComponentID[C](w),
		id3:   ecs.ComponentID[D](w),
		id4:   ecs.ComponentID[E](w),
		id5:   ecs.ComponentID[F](w),
		id6:   ecs.ComponentID[G](w),
		id7:   ecs.ComponentID[H](w),
		id8:   ecs.ComponentID[I](w),
		id9:   ecs.ComponentID[J](w),
		id10:  ecs.ComponentID[K](w),
		id11:  ecs.ComponentID[L](w),
	}
	m.ids = []ecs.ID{m.id0, m.id1, m.id2, m.id3, m.id4, m.id5, m.id6, m.id7, m.id8, m.id9, m.id10, m.id11}
	m.mask = ecs.All(m.ids...)
	m.relation = ecs.ID{}
	m.hasRelation = false
	if len(relation) > 0 {
		m.relation = ecs.TypeID(w, relation[0])
		m.hasRelation = true
	}
	return m
}

// Get all the Map12's components for the given entity.
//
// See [Map12.GetUnchecked] for an optimized version for static entities.
// See also [ecs.World.Get].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Get(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	return (*A)(m.world.Get(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8)),
		(*J)(m.world.GetUnchecked(entity, m.id9)),
		(*K)(m.world.GetUnchecked(entity, m.id10)),
		(*L)(m.world.GetUnchecked(entity, m.id11))
}

// GetUnchecked all the Map12's components for the given entity.
//
// GetUnchecked is an optimized version of [Map12.Get],
// for cases where entities are static or checked with [ecs.World.Alive] in user code.
//
// See also [ecs.World.GetUnchecked].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) GetUnchecked(entity ecs.Entity) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	return (*A)(m.world.GetUnchecked(entity, m.id0)),
		(*B)(m.world.GetUnchecked(entity, m.id1)),
		(*C)(m.world.GetUnchecked(entity, m.id2)),
		(*D)(m.world.GetUnchecked(entity, m.id3)),
		(*E)(m.world.GetUnchecked(entity, m.id4)),
		(*F)(m.world.GetUnchecked(entity, m.id5)),
		(*G)(m.world.GetUnchecked(entity, m.id6)),
		(*H)(m.world.GetUnchecked(entity, m.id7)),
		(*I)(m.world.GetUnchecked(entity, m.id8)),
		(*J)(m.world.GetUnchecked(entity, m.id9)),
		(*K)(m.world.GetUnchecked(entity, m.id10)),
		(*L)(m.world.GetUnchecked(entity, m.id11))
}

// New creates a new [ecs.Entity] with the Map12's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.World.NewEntity].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) New(target ...ecs.Entity) ecs.Entity {
	return newEntity(m.world, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatch creates entities with the Map12's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [Map12.NewBatchQ] and [ecs.Batch.NewBatch].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewBatch(count int, target ...ecs.Entity) {
	newBatch(m.world, count, m.ids, m.relation, m.hasRelation, target...)
}

// NewBatchQ creates entities with the Map12's components.
// It returns a [Query12] over the new entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// Listener notification is delayed until the query is closed of fully iterated.
//
// See also [Map12.NewBatch] and [ecs.Builder.NewBatchQ].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewBatchQ(count int, target ...ecs.Entity) Query12[A, B, C, D, E, F, G, H, I, J, K, L] {
	query := newQuery(m.world, count, m.ids, m.relation, m.hasRelation, target...)
	return Query12[A, B, C, D, E, F, G, H, I, J, K, L]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
		id9:   m.id9,
		id10:  m.id10,
		id11:  m.id11,
	}
}

// NewWith creates a new [ecs.Entity] with the Map12's components, using the supplied values.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.NewBuilderWith].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) NewWith(a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L, target ...ecs.Entity) ecs.Entity {
	if len(target) == 0 {
		return m.world.NewEntityWith(ecs.Component{ID: m.id0, Comp: a},
			ecs.Component{ID: m.id1, Comp: b},
			ecs.Component{ID: m.id2, Comp: c},
			ecs.Component{ID: m.id3, Comp: d},
			ecs.Component{ID: m.id4, Comp: e},
			ecs.Component{ID: m.id5, Comp: f},
			ecs.Component{ID: m.id6, Comp: g},
			ecs.Component{ID: m.id7, Comp: h},
			ecs.Component{ID: m.id8, Comp: i},
			ecs.Component{ID: m.id9, Comp: j},
			ecs.Component{ID: m.id10, Comp: k},
			ecs.Component{ID: m.id11, Comp: l},
		)
	}
	if !m.hasRelation {
		panic("map has no relation defined")
	}
	return ecs.NewBuilderWith(m.world, ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
		ecs.Component{ID: m.id9, Comp: j},
		ecs.Component{ID: m.id10, Comp: k},
		ecs.Component{ID: m.id11, Comp: l},
	).WithRelation(m.relation).New(target[0])
}

// Add the Map12's components to the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.World.Add].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Add(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map12 has no relation")
		}
		m.world.Relations().Exchange(entity, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Add(entity, m.ids...)
	}
}

// AddBatch adds the Map12's components to multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.Batch.Add].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map12 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, m.ids, nil, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, m.ids, nil)
	}
}

// AddBatchQ adds the Map12's components to multiple entities and returns a query over them
// and the newly added Map12's components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.Batch.AddQ].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) AddBatchQ(filter ecs.Filter, target ...ecs.Entity) Query12[A, B, C, D, E, F, G, H, I, J, K, L] {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map12 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, m.ids, nil, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, m.ids, nil)
	}
	return Query12[A, B, C, D, E, F, G, H, I, J, K, L]{
		Query: query,
		id0:   m.id0,
		id1:   m.id1,
		id2:   m.id2,
		id3:   m.id3,
		id4:   m.id4,
		id5:   m.id5,
		id6:   m.id6,
		id7:   m.id7,
		id8:   m.id8,
		id9:   m.id9,
		id10:  m.id10,
		id11:  m.id11,
	}
}

// Assign the Map12's components to the given entity, using the supplied values.
//
// See also [ecs.World.Assign].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Assign(entity ecs.Entity, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L) {
	m.world.Assign(entity,
		ecs.Component{ID: m.id0, Comp: a},
		ecs.Component{ID: m.id1, Comp: b},
		ecs.Component{ID: m.id2, Comp: c},
		ecs.Component{ID: m.id3, Comp: d},
		ecs.Component{ID: m.id4, Comp: e},
		ecs.Component{ID: m.id5, Comp: f},
		ecs.Component{ID: m.id6, Comp: g},
		ecs.Component{ID: m.id7, Comp: h},
		ecs.Component{ID: m.id8, Comp: i},
		ecs.Component{ID: m.id9, Comp: j},
		ecs.Component{ID: m.id10, Comp: k},
		ecs.Component{ID: m.id11, Comp: l},
	)
}

// Remove the Map12's components from the given entity.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.World.Remove].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) Remove(entity ecs.Entity, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map12 has no relation")
		}
		m.world.Relations().Exchange(entity, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Remove(entity, m.ids...)
	}
}

// RemoveBatch removes the Map12's components from multiple entities.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.Batch.Remove].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) RemoveBatch(filter ecs.Filter, target ...ecs.Entity) {
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map12 has no relation")
		}
		m.world.Relations().ExchangeBatch(filter, nil, m.ids, m.relation, target[0])
	} else {
		m.world.Batch().Exchange(filter, nil, m.ids)
	}
}

// RemoveBatchQ adds the Map12's components from multiple entities and returns a query over them,
// with no components.
//
// The optional argument can be used to set the target [ecs.Entity] for the Map12's [ecs.Relation].
//
// See also [ecs.Batch.RemoveQ].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) RemoveBatchQ(filter ecs.Filter, target ...ecs.Entity) Query0 {
	var query ecs.Query
	if len(target) > 0 {
		if !m.hasRelation {
			panic("can't set target entity: Map12 has no relation")
		}
		query = m.world.Relations().ExchangeBatchQ(filter, nil, m.ids, m.relation, target[0])
	} else {
		query = m.world.Batch().ExchangeQ(filter, nil, m.ids)
	}
	return Query0{
		Query: query,
	}
}

// RemoveEntities removes all entities from the world that match the Map12's components.
//
// The argument determines whether to match the components exactly (i.e. no other components are allowed),
// or to use a simple filter that does not restrict further components.
//
// Returns the number of removed entities.
//
// See also [ecs.Batch.RemoveEntities].
func (m *Map12[A, B, C, D, E, F, G, H, I, J, K, L]) RemoveEntities(exclusive bool) int {
	if exclusive {
		filter := m.mask.Exclusive()
		return m.world.Batch().RemoveEntities(&filter)
	}
	return m.world.Batch().RemoveEntities(m.mask)
}
