// ////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2021 Vladislav Fedotov (Falldot)
// License: MIT License
// MIT License web page: https://opensource.org/licenses/MIT
//
// ////////////////////////////////////////////////////////////////////////
//
// This file generated by Entitas-Go generator. PLEASE DO NOT EDIT IT.
//
// Entitas-Go: github.com/Falldot/Entitas-Go
//
// ////////////////////////////////////////////////////////////////////////
package ecs

type entityPool []int

func (s *entityPool) Push(e int) {
	*s = append(*s, e)
}

func (s *entityPool) Pop() (int, bool) {
	lenght := len(*s)
	if lenght > 0 {
		last := lenght - 1
		entity := (*s)[last]
		*s = (*s)[:last]
		return entity, true
	}
	return 0, false
}

type Component interface{}

type componentState []int

func (s *componentState) On(i int, ComponentTotal int) {
	(*s)[i/ComponentTotal] |= 1 << (i % ComponentTotal)
}

func (s *componentState) Off(i int, ComponentTotal int) {
	(*s)[i/ComponentTotal] &^= 1 << (i % ComponentTotal)
}

func (s *componentState) onOff(i int, ComponentTotal int) bool {
	return (*s)[i/ComponentTotal]&(1<<(i%ComponentTotal)) == 0
}

type componentPool []Component

func (s *componentPool) Push(e Component) {
	*s = append(*s, e)
}

func (s *componentPool) Pop() (Component, bool) {
	lenght := len(*s)
	if lenght > 0 {
		last := lenght - 1
		entity := (*s)[last]
		*s = (*s)[:last]
		return entity, true
	}
	return nil, false
}

type onComponent []func(*Entity, int, Component)

func (e *onComponent) On(action func(*Entity, int, Component)) {
	*e = append(*e, action)
}

func (e *onComponent) Execute(en *Entity, id int, c Component) {
	for _, fn := range *e {
		fn(en, id, c)
	}
}

type onEntity []func(*Entity)

func (e *onEntity) On(action func(*Entity)) {
	*e = append(*e, action)
}

func (e *onEntity) Execute(en *Entity) {
	for _, fn := range *e {
		fn(en)
	}
}

type onGroup []func(Group, *Entity, int, Component)

func (e *onGroup) On(action func(Group, *Entity, int, Component)) {
	*e = append(*e, action)
}

func (e *onGroup) Execute(g Group, en *Entity, id int, c Component) {
	for _, fn := range *e {
		fn(g, en, id, c)
	}
}

type onGroupCreate []func(Group)

func (e *onGroupCreate) On(action func(Group)) {
	*e = append(*e, action)
}

func (e *onGroupCreate) Execute(g Group) {
	for _, fn := range *e {
		fn(g)
	}
}

type Contexts []interface{}

func SetContexts(ebs ...interface{}) Contexts {
	var contexts Contexts
	for _, v := range ebs {
		contexts = append(contexts, v)
	}
	return contexts
}

func (c *Contexts) Add(element interface{}) {
	*c = append(*c, element)
}

func (c *Contexts) Get(id int) interface{} {
	return (*c)[id]
}

type Entity struct {
	id             int
	componentTotal int

	components []Component
	componentState
	componentPool *[]componentPool

	onComponentAdd     onComponent
	onComponentRemove  onComponent
	onComponentReplace onComponent
	onComponentOff     onComponent

	onEntityDestroy  onEntity
	onEntityReleased onEntity
}

////////////////////////////////////////////////////////
// Constructor
////////////////////////////////////////////////////////

func createEntity(id int, componentPool *[]componentPool, componentTotal int) *Entity {
	return &Entity{
		id:             id,
		componentPool:  componentPool,
		components:     make([]Component, componentTotal),
		componentTotal: componentTotal,
		componentState: make(componentState, componentTotal),
	}
}

////////////////////////////////////////////////////////
// Public
////////////////////////////////////////////////////////

func (e *Entity) ID() int {
	return e.id
}

func (e *Entity) Destroy() {
	e.componentState = make(componentState, e.componentTotal)
	e.onComponentOff = e.onComponentOff[:1]
	e.onComponentAdd = e.onComponentAdd[:1]
	e.onComponentReplace = e.onComponentReplace[:1]
	e.onComponentRemove = e.onComponentRemove[:2]
	e.onEntityDestroy.Execute(e)
}

func (e *Entity) OnComponentAdd(action func(*Entity, int, Component)) {
	e.onComponentAdd.On(action)
}

func (e *Entity) OnComponentRemoved(action func(*Entity, int, Component)) {
	e.onComponentRemove.On(action)
}

func (e *Entity) OnComponentReplaced(action func(*Entity, int, Component)) {
	e.onComponentReplace.On(action)
}

func (e *Entity) OnComponentOff(action func(*Entity, int, Component)) {
	e.onComponentOff.On(action)
}

func (e *Entity) OnEntityDestroy(action func(*Entity)) {
	e.onEntityDestroy.On(action)
}

func (e *Entity) OnEntityReleased(action func(*Entity)) {
	e.onEntityReleased.On(action)
}

func (e *Entity) Has(tp ...int) bool {
	for _, v := range tp {
		if e.componentState.onOff(v, e.componentTotal) {
			return false
		}
	}
	return true
}

func (e *Entity) Any(tp ...int) bool {
	for _, v := range tp {
		if !e.componentState.onOff(v, e.componentTotal) {
			return true
		}
	}
	return false
}

func (e *Entity) On(tp int) {
	e.componentState.On(tp, e.componentTotal)
}

func (e *Entity) Off(tp int) {
	e.componentState.Off(tp, e.componentTotal)
}

func (e *Entity) Remove(tp int) {
	e.onComponentRemove.Execute(e, tp, e.components[tp])
}

func (e *Entity) Get(tp int) Component {
	return e.components[tp]
}

func (e *Entity) Add(tp int, component Component) {
	e.components[tp] = component
	e.onComponentAdd.Execute(e, tp, component)
}

func (e *Entity) Replace(tp int, component Component) {
	if e.components[tp] == nil {
		e.Add(tp, component)
	} else {
		e.components[tp] = component
		e.onComponentReplace.Execute(e, tp, component)
	}
}

func (e *Entity) Create(tp int) (Component, bool) {
	return (*e.componentPool)[tp].Pop()
}

type EntityBase interface {
	/////////////////////////////////////////////////////
	//Public:

	CreateEntity() *Entity
	Group(Matcher) Group
	Collector(Matcher) Collector

	OnGroupCreated(func(Group))

	OnEntityCreated(func(*Entity))
	OnEntityWillBeDestroyed(func(*Entity))
	OnEntityDestroyed(func(*Entity))

	/////////////////////////////////////////////////////
	//Private:
	destroyEntity(e *Entity)
	removeComponent(e *Entity, tp int, c Component)
}

type entityBase struct {
	componentTotal int

	entities []*Entity
	entityPool
	componentPool []componentPool

	groups      map[int]Group
	groupsIndex [][]Group

	onGroupCreated onGroupCreate

	onEntityCreated         onEntity
	onEntityWillBeDestroyed onEntity
	onEntityDestroyed       onEntity
}

/////////////////////////////////////////////////////
// Constructor:
/////////////////////////////////////////////////////

func CreateEntityBase(componentTotal int) EntityBase {
	return &entityBase{
		componentTotal: componentTotal,
		groupsIndex:    make([][]Group, componentTotal),
		componentPool:  make([]componentPool, componentTotal),
		groups:         make(map[int]Group),
	}
}

/////////////////////////////////////////////////////
// Public:
/////////////////////////////////////////////////////

func (eb *entityBase) CreateEntity() *Entity {
	var entity *Entity

	if id, ok := eb.entityPool.Pop(); ok {
		entity = eb.entities[id]
	} else {
		entity = createEntity(len(eb.entities), &eb.componentPool, eb.componentTotal)
		eb.entities = append(eb.entities, entity)
		entity.OnEntityDestroy(eb.destroyEntity)
		entity.OnComponentRemoved(eb.removeComponent)
		entity.OnComponentRemoved(eb.updateGroupsComponentRemoved)
		entity.OnComponentOff(eb.updateGroupsComponentRemoved)
		entity.OnComponentAdd(eb.updateGroupsComponentAdded)
		entity.OnComponentReplaced(eb.updateGroupsComponentReplaced)
	}

	if eb.onEntityCreated != nil {
		eb.onEntityCreated.Execute(entity)
	}

	return entity
}

func (eb *entityBase) OnGroupCreated(action func(Group)) {
	eb.onGroupCreated.On(action)
}

func (eb *entityBase) OnEntityCreated(action func(*Entity)) {
	eb.onEntityCreated.On(action)
}

func (eb *entityBase) OnEntityWillBeDestroyed(action func(*Entity)) {
	eb.onEntityWillBeDestroyed.On(action)
}

func (eb *entityBase) OnEntityDestroyed(action func(*Entity)) {
	eb.onEntityDestroyed.On(action)
}

func (eb *entityBase) Group(matcher Matcher) Group {
	hash := matcher.getHashCode()

	if g, ok := eb.groups[hash]; ok {
		return g
	}

	g := newGroup(matcher)

	for _, v := range eb.entities {
		g.handleEntitySilently(v)
	}

	eb.groups[hash] = g

	for _, v := range matcher.getIndices() {
		eb.groupsIndex[v] = append(eb.groupsIndex[v], g)
	}

	if eb.onGroupCreated != nil {
		eb.onGroupCreated.Execute(g)
	}

	return g
}

func (eb *entityBase) Collector(matcher Matcher) Collector {
	g := eb.Group(matcher)
	return newCollector(g)
}

/////////////////////////////////////////////////////
// Private:
/////////////////////////////////////////////////////

func (eb *entityBase) updateGroupsComponentRemoved(entity *Entity, index int, component Component) {
	entity.componentState.Off(index, eb.componentTotal)
	for _, v := range eb.groupsIndex[index] {
		v.handleEntity(entity, index, component)
	}
}

func (eb *entityBase) updateGroupsComponentAdded(entity *Entity, index int, component Component) {
	entity.componentState.On(index, eb.componentTotal)
	for _, v := range eb.groupsIndex[index] {
		v.handleEntity(entity, index, component)
	}
}

func (eb *entityBase) updateGroupsComponentReplaced(entity *Entity, index int, component Component) {
	for _, v := range eb.groupsIndex[index] {
		v.updateEntity(entity, index, component)
	}
}

func (eb *entityBase) destroyEntity(e *Entity) {
	e.onEntityDestroy = e.onEntityDestroy[:1]
	if eb.onEntityWillBeDestroyed != nil {
		eb.onEntityWillBeDestroyed.Execute(e)
	}
	eb.entityPool.Push(e.id)
	if eb.onEntityDestroyed != nil {
		eb.onEntityDestroyed.Execute(e)
	}
}

func (eb *entityBase) removeComponent(e *Entity, tp int, c Component) {
	eb.componentPool[tp].Push(c)
	e.components[tp] = nil
	e.componentState.Off(tp, eb.componentTotal)
}

type Matcher interface {

	/////////////////////////////////////////////////////
	//Public:
	AllOf(indices ...int) Matcher
	AnyOf(indices ...int) Matcher
	NoneOf(indices ...int) Matcher

	/////////////////////////////////////////////////////
	//Private:

	getIndices() []int
	matches(entity *Entity) bool
	getHashCode() int
}

type matcher struct {
	allOfIndices  []int
	anyOfIndices  []int
	noneOfIndices []int

	indices []int

	hash        int
	isHashCache bool
}

/////////////////////////////////////////////////////
// Constructor:
/////////////////////////////////////////////////////

func NewMatcher() Matcher {
	return &matcher{}
}

/////////////////////////////////////////////////////
// Public:
/////////////////////////////////////////////////////

func (m *matcher) AllOf(indices ...int) Matcher {
	m.allOfIndices = append(m.allOfIndices, indices...)
	m.indices = append(m.indices, indices...)
	return m
}

func (m *matcher) AnyOf(indices ...int) Matcher {
	m.anyOfIndices = append(m.anyOfIndices, indices...)
	m.indices = append(m.indices, indices...)
	return m
}

func (m *matcher) NoneOf(indices ...int) Matcher {
	m.noneOfIndices = append(m.noneOfIndices, indices...)
	m.indices = append(m.indices, indices...)
	return m
}

/////////////////////////////////////////////////////
// Private:
/////////////////////////////////////////////////////

func (m *matcher) getIndices() []int {
	return m.indices
}

func (m *matcher) matches(entity *Entity) bool {
	return (m.allOfIndices == nil || entity.Has(m.allOfIndices...)) &&
		(m.anyOfIndices == nil || entity.Any(m.anyOfIndices...)) &&
		(m.noneOfIndices == nil || !entity.Has(m.noneOfIndices...))
}

func (m *matcher) getHashCode() int {
	if !m.isHashCache {
		var hash int
		hash = applyHash(hash, m.allOfIndices, 3, 53)
		hash = applyHash(hash, m.anyOfIndices, 307, 367)
		hash = applyHash(hash, m.noneOfIndices, 647, 683)
		m.hash = hash
		m.isHashCache = true
	}
	return m.hash
}

func applyHash(hash int, indices []int, i1 int, i2 int) int {
	if indices != nil {
		for _, v := range indices {
			hash ^= v * i1
		}
		hash ^= len(indices) * i2
	}
	return hash
}

type Group interface {
	/////////////////////////////////////////////////////
	//Public:

	Lenght() int
	GetEntities() []*Entity

	OnEntityAdded(func(Group, *Entity, int, Component))
	OnEntityRemoved(func(Group, *Entity, int, Component))
	OnEntityUpdate(func(Group, *Entity, int, Component))

	/////////////////////////////////////////////////////
	//Private:

	has(entity *Entity) bool

	updateEntity(entity *Entity, index int, component Component)

	handleEntity(entity *Entity, index int, component Component)
	handleEntitySilently(entity *Entity)

	addEntitySilently(entity *Entity)
	addEntity(entity *Entity, index int, component Component)

	removeEntitySilently(entity *Entity)
	removeEntity(entity *Entity, index int, component Component)
}

type group struct {
	matcher Matcher

	entities           map[int]*Entity
	entitiesCache      []*Entity
	entitieSingleCache *Entity

	onEntityAdded   onGroup
	onEntityRemoved onGroup
	onEntityUpdate  onGroup
}

/////////////////////////////////////////////////////
//Constructor:
/////////////////////////////////////////////////////

func newGroup(matcher Matcher) Group {
	return &group{
		matcher:  matcher,
		entities: make(map[int]*Entity),
	}
}

/////////////////////////////////////////////////////
//Public:
/////////////////////////////////////////////////////

func (g *group) Lenght() int {
	return len(g.entities)
}

func (g *group) GetEntities() []*Entity {
	if g.entitiesCache == nil {
		g.entitiesCache = make([]*Entity, 0, len(g.entities))
		for _, v := range g.entities {
			g.entitiesCache = append(g.entitiesCache, v)
		}
	}
	return g.entitiesCache
}

func (g *group) GetSingleEntity() *Entity {
	if g.entitieSingleCache == nil {
		count := len(g.entities)
		if count == 1 {
			for _, v := range g.entities {
				g.entitieSingleCache = v
			}
		} else {
			return nil
		}
	}
	return g.entitieSingleCache
}

func (g *group) OnEntityAdded(action func(Group, *Entity, int, Component)) {
	g.onEntityAdded.On(action)
}

func (g *group) OnEntityRemoved(action func(Group, *Entity, int, Component)) {
	g.onEntityRemoved.On(action)
}

func (g *group) OnEntityUpdate(action func(Group, *Entity, int, Component)) {
	g.onEntityUpdate.On(action)
}

/////////////////////////////////////////////////////
//Private:
/////////////////////////////////////////////////////

func (g *group) has(entity *Entity) bool {
	return g.entities[entity.ID()] != nil
}

func (g *group) updateEntity(entity *Entity, index int, component Component) {
	if g.onEntityUpdate != nil {
		g.onEntityUpdate.Execute(g, entity, index, component)
	}
}

func (g *group) handleEntity(entity *Entity, index int, component Component) {
	if g.matcher.matches(entity) {
		g.addEntity(entity, index, component)
	} else {
		g.removeEntity(entity, index, component)
	}
}

func (g *group) handleEntitySilently(entity *Entity) {
	if g.matcher.matches(entity) {
		g.addEntitySilently(entity)
	}
}

func (g *group) addEntitySilently(entity *Entity) {
	g.entities[entity.ID()] = entity
	if g.entitiesCache != nil {
		g.entitiesCache = append(g.entitiesCache, entity)
	}
}

func (g *group) addEntity(entity *Entity, index int, component Component) {
	g.addEntitySilently(entity)
	if g.onEntityAdded != nil {
		g.onEntityAdded.Execute(g, entity, index, component)
	}
}

func (g *group) removeEntitySilently(entity *Entity) {
	delete(g.entities, entity.ID())
	g.entitiesCache = nil
}

func (g *group) removeEntity(entity *Entity, index int, component Component) {
	g.removeEntitySilently(entity)
	if g.onEntityRemoved != nil {
		g.onEntityRemoved.Execute(g, entity, index, component)
	}
}

type Collector interface {

	/////////////////////////////////////////////////////
	//Public:

	Entities() []*Entity

	OnAdd() Collector
	//OnRemove() Collector
	OnUpdate() Collector

	Clear()
	/////////////////////////////////////////////////////
	//Private:
}

type collector struct {
	group    Group
	entities []*Entity
}

/////////////////////////////////////////////////////
// Constructor:
/////////////////////////////////////////////////////

func newCollector(group Group) Collector {
	return &collector{group: group}
}

/////////////////////////////////////////////////////
// Public:
/////////////////////////////////////////////////////

func (c *collector) Entities() []*Entity {
	return c.entities
}

func (c *collector) OnAdd() Collector {
	c.group.OnEntityAdded(c.addEntity)
	return c
}

// func (c *collector) OnRemove() Collector {
// 	c.group.OnEntityRemoved(c.addEntity)
// 	return c
// }

func (c *collector) OnUpdate() Collector {
	c.group.OnEntityUpdate(c.addEntity)
	return c
}

/////////////////////////////////////////////////////
// Private:
/////////////////////////////////////////////////////

func (c *collector) Clear() {
	c.entities = c.entities[:0]
}

func (c *collector) addEntity(g Group, e *Entity, tp int, cm Component) {
	c.entities = append(c.entities, e)
}

type Initer interface {
	Initer(Contexts)
}

type Executer interface {
	Executer()
}

type Cleaner interface {
	Cleaner()
}

type Reactive interface {
	Trigger(contexts Contexts) Collector
	Filter(entity *Entity) bool
	Executer(entities []*Entity)
}

type Exiter interface {
	Exiter(Contexts)
}

type Systems interface {
	Init(contexts Contexts)
	Execute()
	Clean()
	Exit(contexts Contexts)

	Add(action interface{})
}

type systems struct {
	initers   []Initer
	executers []Executer
	cleaners  []Cleaner
	exiters   []Exiter

	reactives  []Reactive
	collectors []Collector
}

/////////////////////////////////////////////////////
// Constructor:
/////////////////////////////////////////////////////

func CreateSystemPool() Systems {
	return &systems{}
}

/////////////////////////////////////////////////////
// Public:
/////////////////////////////////////////////////////

func (s *systems) Init(contexts Contexts) {
	for _, v := range s.initers {
		v.Initer(contexts)
	}
	s.collectors = make([]Collector, len(s.reactives))
	for i, v := range s.reactives {
		s.collectors[i] = v.Trigger(contexts)
	}
}

func (s *systems) Execute() {
	for _, v := range s.executers {
		v.Executer()
	}
	for i, v := range s.reactives {
		if s.collectors[i] != nil {
			var buffer []*Entity
			entities := s.collectors[i].Entities()
			if len(entities) != 0 {
				for _, e := range entities {
					if v.Filter(e) {
						buffer = append(buffer, e)
					}
				}

				s.collectors[i].Clear()

				if len(buffer) != 0 {
					v.Executer(buffer)
				}
			}
		}
	}
}

func (s *systems) Clean() {
	for _, v := range s.cleaners {
		v.Cleaner()
	}
}

func (s *systems) Exit(contexts Contexts) {
	for _, v := range s.exiters {
		v.Exiter(contexts)
	}
}

func (s *systems) Add(action interface{}) {
	switch action := action.(type) {
	case Reactive:
		s.reactives = append(s.reactives, action)
	}

	switch action := action.(type) {
	case Initer:
		s.initers = append(s.initers, action)
	}

	switch action := action.(type) {
	case Executer:
		s.executers = append(s.executers, action)
	}

	switch action := action.(type) {
	case Cleaner:
		s.cleaners = append(s.cleaners, action)
	}

	switch action := action.(type) {
	case Exiter:
		s.exiters = append(s.exiters, action)
	}
}
