{"/arche/background/":{"data":{"":"Background information on Arche’s design, architecture, performance and history."},"title":"Background"},"/arche/background/architecture/":{"data":{"":"Arche uses an archetype-based architecture. Therefore the name :wink:.\nThis chapter explains the concept and Arche’s take on it.","archetypes#Archetypes":"The ASCII graph below illustrates the approach. Components for entities are stored in so-called archetypes. Archetypes represent unique combinations of components. This means that component data for all entities with exactly the same component is stored in the same archetype.\nIn the illustration below, the first archetype holds entities with (only/exactly) the components A, B and C, as well as their components. Similarly, the second archetype contains all entities with A and C, and their components.\n1 Entities Archetypes Bit masks Queries 2 3 E E Comps 4 |0| |2|A|B|C| 111... \u003c-. \u003c---. 5 |1|---. |8|A|B|C| | | 6 |2| '--\u003e|1|A|B|C| | | 7 |3| |3|A|B|C| |--Q(A,C) | 8 |4| | 101... | 9 |6| .--\u003e|7|A|C| 101... \u003c-' |--Q(B) 10 |7|---' |6|A|C| | 010... 11 |8| |4|A|C| | 12 |9|---. | 13 |.| | |5|B|C| 011... \u003c---' 14 |.| '--\u003e|9|B|C| 15 |.| 16 |.| \u003c===\u003e [Entity pool] Illustration of Arche’s archetype-based architecture.\nThe exact component composition of each archetype is encoded in a bitmask for fast comparison. Thus, queries can easily identify their relevant archetypes, and then simply iterate entities linearly, which is very fast and cache-friendly. Components can be accessed through a query in a very efficiently (≈1ns).","details#Details":"Actually, the explanation above is quite simplified. Particularly it leaves out Entity Relations and the archetypes graph and nodes.\nArchetype graph When components are added to or removed from an entity, it is necessary to find its new archetype. To accelerate the search, a graph of archetype nodes (or just nodes) is used. The figure below illustrates the concept. Each arrow represents the transition between two archetypes when a single component is added (solid arrow head) or removed (empty arrow head). Following these transitions, the archetype resulting from addition and/or removal of an arbitrary number of components can be found easily.\nIllustration of the archetype graph. Letters represent components. Boxes represent archetype nodes. Arrows represent transitions when a single component is added or removed.\nNodes and connections are created as needed. When searching for an archetype, the algorithm proceeds transition by transition. When looking for the next archetype, established transitions are checked first. If this is not successful, the resulting component mask is used to search through all nodes. On success, a new connection is established. If the required node was still not found, a new node is created. Then, the next transition it processed and so on, until the final node is found. Only then, an archetype is created for the node.\nAs a result, the graph will in most cases not be fully connected. There will also not be all possible nodes (combinations of components) present. Nodes that are only traversed by the search but never receive entities contain no archetype and are called inactive.\nThe graph stabilizes quickly. Then, only the fast following of transitions is required to find an archetype when components are added or removed. Transitions are stored in the nodes with lookup approx. 10 times faster than Go’s map.\nEntity relations The archetype nodes explained above are utilized to implement Arche’s Entity Relations feature. When an archetype contains a relation components, the respective node contains an archetype “table” for each entity that is a target of that relation. As an example, we have components A, B and R, where R is a relation. Further, we have two parent entities E1 and E2. When you create some entities with components A B R(E1) and A B R(E2), i.e. with relation targets E1 and E2, the following node is created:\n1 2 Node [ A B R ] 3 | 4 |--- E1 E Comps 5 | |3|A|B|R| 6 | |6|A|B|R| 7 | |7|A|B|R| 8 | 9 '--- E2 E Comps 10 |4|A|B|R| 11 |5|A|B|R| When querying without specifying a target, the “inner” archetypes are simply iterated if the node matches the filter. When querying with a relation target (and the node matches), the archetype for the target entity is looked up in a standard Go map.\nArchetype removal Normal archetypes without a relation are never removed, because they are not a temporary thing. For relation archetypes, however, things are different. Once a target entity dies, it will never appear again (actually it could, after dying another 4294967294 times).\nIn Arche, empty archetypes with a dead target are recycled. They are deactivated, but their allocated memory for entities and components is retained. When an archetype in the same node, but for another target entity is requested, it is reused. To be able to efficiently detect whether an archetype can be removed, a bitset is used to keep track of entities that are the target of a relation.","performance#Performance":"Obviously, archetypes are an optimization for iteration speed. But they also come with a downside. Adding or removing components to/from an entity requires moving all the components of the entity to another archetype. This takes roughly 10-20ns per involved component. To reduce the number of archetype changes, it is recommended to add/remove/exchange multiple components at the same time rather than one after the other.\nHowever, as the benchmarks on the repo README illustrate, Arche seems to be the fastest Go ECS available. Not only in terms of iteration speed, which is particularly tailored for. Even when it comes to entity manipulation (adding, removing components etc.), where sparse-set ECS implementations should shine, Arche leads the field.\nFor more numbers on performance, see chapter Benchmarks.","world-entity-access#World entity access":"For getting components by entity, e.g. for hierarchies, the world contains a list that is indexed by the entity ID (left-most in the figure). For each entity, it references its current archetype and the position of the entity in the archetype. This way, getting components for entities (i.e. random access) is fast, although not as fast as in queries (≈2ns vs. 1ns).\nNote that the entities list also contains entities that are currently not alive, because they were removed. These entities are recycled when new entities are requested from the ecs.World. Therefore, besides the ID shown in the illustration, each entity also has a generation variable. It is incremented on each “reincarnation” of an entity. Thus, it allows to distinguish recycled from dead entities, as well as from previous or later “incarnations”."},"title":"Architecture"},"/arche/background/benchmarks/":{"data":{"":"","components#Components":"","components-batched#Components, batched":"","entities#Entities":"","entities-batched#Entities, batched":"","other#Other":"This chapter gives an overview of the runtime cost of typical Arche operations. All time information is per entity. All components used in the benchmarks have two int64 fields. Batch operations are performed in batches of 1000 entities.\nAbsolute numbers are not really meaningful, as they heavily depend on the hardware. However, all benchmarks run in the CI in the same job and hence on the same machine, and can be compared.\nBenchmark code: benchmark/table in the GitHub repository.\nBenchmarks are run automatically in the GitHub CI, and are updated on this page on every merge into the main branch. They always reflect the latest development state of Arche.\nFor a benchmark comparison with other ECS implementations, see the go-ecs-benchmarks repository.\nLast run: Tue, 01 Apr 2025 08:46:24 UTC\nVersion: Arche v0.15.3\nCPU: AMD EPYC 7763 64-Core Processor\nQuery Operation Time Remark Query.Next 1.0 ns Query.Next + 1x Query.Get 1.7 ns Query.Next + 2x Query.Get 1.9 ns Query.Next + 5x Query.Get 4.5 ns Query.Next + Query.Entity 1.7 ns Query.Next + Query.Relation 2.3 ns Query.EntityAt, 1 arch 12.0 ns Query.EntityAt, 1 arch 3.2 ns registered filter Query.EntityAt, 5 arch 30.8 ns Query.EntityAt, 5 arch 5.0 ns registered filter World.Query 30.5 ns World.Query 34.9 ns registered filter World access Operation Time Remark World.Get 2.1 ns random, 1000 entities World.GetUnchecked 1.5 ns random, 1000 entities World.Has 1.2 ns random, 1000 entities World.HasUnchecked 0.7 ns random, 1000 entities World.Alive 0.4 ns random, 1000 entities World.Relations.Get 3.4 ns random, 1000 entities World.Relations.GetUnchecked 0.8 ns random, 1000 entities Entities Operation Time Remark Entity.IsZero 0.2 ns World.NewEntity 17.2 ns memory already alloc. World.NewEntity w/ 1 Comp 24.1 ns memory already alloc. World.NewEntity w/ 5 Comps 47.0 ns memory already alloc. World.RemoveEntity 16.2 ns World.RemoveEntity w/ 1 Comp 27.7 ns World.RemoveEntity w/ 5 Comps 60.5 ns Map1.NewWith 1 Comp 31.4 ns memory already alloc. Map5.NewWith 5 Comps 72.9 ns memory already alloc. Entities, batched Operation Time Remark Batch.New 9.6 ns 1000, memory already allocated Batch.New w/ 1 Comp 9.9 ns 1000, memory already allocated Batch.New w/ 5 Comps 9.7 ns 1000, memory already allocated Batch.RemoveEntities 7.1 ns 1000 Batch.RemoveEntities w/ 1 Comp 7.6 ns 1000 Batch.RemoveEntities w/ 5 Comps 8.7 ns 1000 Components Operation Time Remark World.Add 1 Comp 41.4 ns memory already alloc. World.Add 5 Comps 71.6 ns memory already alloc. World.Add 1 to 5 Comps 114.0 ns memory already alloc. World.Remove 1 Comp 50.9 ns memory already alloc. World.Remove 5 Comps 110.1 ns memory already alloc. World.Remove 1 of 5 Comps 107.3 ns memory already alloc. World.Exchange 1 Comp 59.1 ns memory already alloc. World.Exchange 1 of 5 Comps 112.6 ns memory already alloc. Map1.Assign 1 Comps 48.1 ns memory already alloc. Map5.Assign 5 Comps 97.7 ns memory already alloc. Components, batched Operation Time Remark Batch.Add 1 Comp 4.3 ns 1000, memory already allocated Batch.Add 5 Comps 4.4 ns 1000, memory already allocated Batch.Add 1 to 5 Comps 7.9 ns 1000, memory already allocated Batch.Remove 1 Comp 4.5 ns 1000, memory already allocated Batch.Remove 5 Comps 5.8 ns 1000, memory already allocated Batch.Remove 1 of 5 Comps 7.0 ns 1000, memory already allocated Batch.Exchange 1 Comp 4.6 ns 1000, memory already allocated Batch.Exchange 1 of 5 Comps 7.0 ns 1000, memory already allocated Other Operation Time Remark ecs.NewWorld 6.7 μs World.Reset 80.0 ns empty world ecs.ComponentID 22.1 ns component already registered ","query#Query":"","world-access#World access":""},"title":"Benchmarks"},"/arche/background/changelog/":{"data":{"":"","v0100httpsgithubcommlange-42archecomparev090v0100#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.9.0...v0.10.0\"\u003e[v0.10.0]\u003c/a\u003e":"","v0101httpsgithubcommlange-42archecomparev0100v0101#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.10.0...v0.10.1\"\u003e[v0.10.1]\u003c/a\u003e":"","v010httpsgithubcommlange-42archetreev010#\u003ca href=\"https://github.com/mlange-42/arche/tree/v0.1.0\"\u003e[v0.1.0]\u003c/a\u003e":"[v0.15.3] Performance Avoids heap allocations in generic MapX by using arrays for IDs (#478) Documentation Migrates the user guide to the Hextra theme (#488, #489) [v0.15.2] Performance Speeds up reset of small archetypes by zeroing memory manually (#475) [v0.15.1] Performance Optimizes batch operations (add, remove, exchange) by bulk-copying components (#473) Documentation Adds benchmarks to the user guide for 1-of-5 components operations (e.g. remove 1 of 5) (#474) [v0.15.0] Arche v0.15.0 features optimizations that vastly speed up the creation of huge numbers (millions) of entities. Namely, all memory is grown exponentially now, rather than linearly. This also causes a breaking change, as the former “capacity increments” turned into just initial capacities.\nFurther, the README was revised and the ECS competition benchmarks were extended and moved to the go-ecs-benchmarks repository.\nBreaking changes Removes ecs.Config; the world is configured with initial capacities directly (#467) Features Adds methods Batch.New and Batch.NewQ for batch entity creation (#468) Deprecates ecs.Component, as a followup of deprecation of all methods that use it (#470) Performance Optimizes entity creation by an altered growth policy for archetypes, entity list and entity pool (#464, #466, #469) Documentation Rewrites features and benchmarks sections of the README (#462) Adds version and CPU information to the benchmarks in the user guide (#462) Removed deprecated methods from the benchmarks in the user guide (#462) Adds world creation and component ID lookup to the benchmarks in the user guide (#462) Uses the new methods Batch.New and Batch.NewQ in examples where applicable, instead of Builder (#470) Other Uses mask pointers in all tests and benchmarks (#460) [v0.14.5] Documentation Adds notes on entity and component pointer usage to docs and the user guide (#455) Improves sub-package documentation for navigation and findability (#457) [v0.14.4] Performance Optimizes mask to types conversion, speeding up archetype creation by up to 150ns (#453) [v0.14.3] Performance Avoids a bitmask heap escape in world component operations (add, remove, exchange, …), with around 20ns improvement (#452) [v0.14.2] Performance Optimizes MapX.Assign and MapX.NewWith by use of World.GetUnchecked (#449) Documentation Fixes method names and ordering in benchmark tables (#448) Documents listener notification handling in MapX.NewWith (#450) Bugfixes Fixes missing listener notification in MapX.NewWith when called with a relation target (#450) [v0.14.1] Features Adds World.NewEntityFn, World.AddFn and World.ExchangeFn that call a callback function before listener notification (#445) Bugfixes Fixes generic MapX.Assign and MapX.NewWith notifying listeners before setting components (#445, issue #443) Documentation Removes references to deprecated methods from the user guide (#447) Other Retract version v0.14.0 due to issue #443 and required features (#446) [v0.14.0] Features Slow assignment methods like World.Assign and World.NewEntityWith are deprecated, in favour of their now faster generic counterparts (#441) Performance Optimizes Map.Set, MapX.Assign and MapX.NewWith, by not using runtime reflection (#440) Documentation Adds benchmarks for World.Assign and World.NewEntityWith to the user guide (#438) Adds benchmarks for MapX.Assign and MapX.NewWith to the user guide (#440) Bugfixes Prevents garbage collection of slices and pointers in components added via World.Assign and similar methods (#438, issue #437) Known issues Generic MapX.Assign and MapX.NewWith notify listeners before setting components (#443) [v0.13.3] Performance Simplifies the archetype graph to use only a single list of neighbors per node, saving a bit of memory (#433) Documentation Adds an example for World.Mask, showing how to check whether a filter “contains” an entity (#428) Adds the beecs implementation of BEEHAVE to the showcase (#429) [v0.13.2] Bugfixes Ensure Assign() copies components before notifying listeners (#426, g-getsov) [v0.13.1] Bugfixes Fixes dispatch listener bug that did not clear component restriction (#424, g-getsov) [v0.13.0] Features Adds function ResourceTypeID to register/get a resource ID from a reflect.Type (#420) Other Fix component type in examples/base (#419) [v0.12.0] Features Adds Entity.ID() and Entity.Generation() (#408, delaneyj) Documentation Adds a showcase chapter “Made with Arche” to the documentation page (#411) Performance Re-arrange struct fields to save memory in a few places (#413) Bugfixes Fix crash caused by extending layouts of an inactive archetype (#416, reported in #415) First-time contributors delaneyj [v0.11.0] Highlights Arche now has a dedicated documentation site with a structured user guide and background information. We hope that this will lower the barrier to entrance significantly.\nFurther, Arche got a few new features:\nQuery.EntityAt was added for random access to query entities. Generic filters now support Exclusive, like ID-based filters. Build tag debug improves error messages in a few places where we rely on standard library panics for performance. Breaking changes Renames types in ecs.stats to follow Go standards. stats.WorldStats -\u003e stats.World, stats.NodeStats -\u003e stats.Node, … (#388) Features Adds method Query.EntityAt(), useful for things like random sampling of entities (#358) Adds build tag debug to improve error messages in a few places where we rely on standard library panics for performance (#377) Adds method FilterX.Exclusive() to all generic filters (#381) Documentation Adds a dedicated Arche User Guide web site (#380, #382, #383, #384, #385) Adds BENCHMARKS.md benchmarks for a tabular overview of the runtime cost of typical Arche ECS operations (#367, #372) Link benchmarking code in README.md and benchmarking tables (#375) Documents build tags tiny and debug in package docs of ecs (#377) Adds examples to demonstrate the use of non-ECS data structures together with ECS (#379) Bugfixes Prevents using the same component multiple times in any operations, through panic (#357) Performance Generic filters use Mask instead of slower MaskFilter if no components are excluded (#381) Other Improves error messages for running out of world locks, components or resources, and on unbalanced unlock (#363) Adds benchmarks for query creation (#366) Upgrade to Go 1.22 in CI (#376) Renames directory examples to _examples to accommodate changed test coverage behaviour of Go 1.22 (#376) In unit tests, error messages of all panics are asserted (#377) [v0.10.1] Bugfixes Fix IsRelation check to allow for non-struct components, like type aliases (#354) Other Repository arche-demo provides a live demo of several models built with Arche. [v0.10.0] Highlights Arche supports full world serialization and deserialization, in conjunction with arche-serde (#319) Supports 256 instead of 128 component types as well as resource types and engine locks (#313) Generic API supports up to 12 instead of 8 component types (#324) Reworked event system with granular subscription to different event types and components (#333, #334, #335, #337, #340) Breaking changes MaskTotalBits changed from 128 to 256 (#313) Removes Mask.Lo and Mask.Hi, internal mask representation is now private (#313) Filter.Matches(Mask) became Filter.Matches(*Mask); same for all Filter implementations (#313)\nThis change was necessary to get the same performance as before, despite the more heavyweight implementation of the now 256 bits Mask. Component and resource IDs are now opaque types instead of type aliases for uint8 (#330) Restructures EntityEvent to remove redundant information and better handle relation changes (#333) World event listener changed from a simple function to a Listener interface (#334) Removes World.ComponentType(ID), use function ComponentInfo(ID) instead (#341) Features Adds functions ComponentInfo(*World, ID) and ResourceType(*World, ResID) (#315, #318) Adds methods World.Ids(Entity) and Query.Ids() to get component IDs for an entity (#315, #325) Entities support JSON marshalling and unmarshalling (#319) The world’s entity state can be extracted and re-established via World.DumpEntities() and World.LoadEntities() (#319, #326) Adds functions ComponentIDs(*World) and ResourceIDs(*World) to get all registered IDs (#330) Adds methods Mask.And, Mask.Or and Mask.Xor (#335) Adds build tag tiny to restrict to 64 components for an extra bit of performance (#338) Adds methods Relations.Exchange(), Relations.ExchangeBatch(), Relations.ExchangeBatchQ() for exchange with relation target (#342) Generic API adds Exchange.WithRelation() and optional target argument for operations with relation target (#342) Generic API adds MapX.AddBatch(), MapX.AddBatchQ(), MapX.RemoveBatch()and MapX.RemoveBatchQ() (#342) Generic API adds optional relation target argument to most MapX methods (#342) Generic API adds FilterX.Filter() to get an ecs.Filter from a generic one (#342) Generic API adds Map.SetRelationBatch() and Map.SetRelationBatchQ() (#344) All batch operations (except entity creation) return the number of affected entities (#348) Performance Reduces archetype memory footprint by using a dynamically sized slice for storage lookup (#327) Reduces event listener overhead through granular subscriptions and elimination of a heap allocation (#333, #334, #335, #337, #340) Documentation Adds an overview to packages ecs and generic on how to achieve ECS manipulation operations (#345) Other Entity generation data type changed from uint16 to uint32 (#317) Adds unitoftime/ecs to competition benchmarks (#311) Adds competition benchmarks for accessing 10 components (#328) [v0.9.0] Infrastructure Upgraded to Go 1.21 toolchain (#308) [v0.8.1] Documentation Emphasize in Entity and World docs that entities are intended to be stored and passed by copy, not by pointer (#306) [v0.8.0] Highlights Entity relations were added as a first-class feature (#231, #271)\nRelations are used to represent graphs of entities, e.g. hierarchies. They can be added, removed and queried just like normal components. The new feature offers ergonomic handling of entity relations, and provides relation queries with native performance.\nBreaking changes Removed World.Batch for entity batch creation, use Builder instead (#239) Rework of generic entity creation API, use MapX.New, MapX.NewWith, MapX.NewBatch and MapX.NewQuery (#239, #252) Stats object WorldStats etc. adapted for new structure of archetypes nested in nodes (#258) Removed generic filter method FilterX.Filter (#271) Method Batch.NewQuery renamed to Batch.NewBatchQ (#298) Features Relation archetypes are removed when they are empty and the target entity is dead (#238, #242) Support an unlimited number of cached filters, instead of 128 (#245) WorldStats contains the number of cached filters (#247) Archetypes with entity relations are removed on World.Reset (#247) Capacity increment can be configured separately for relation archetypes (#257) Adds methods for faster, unchecked entity relation access (#259) Re-introduce World.Batch for batch-processing of entities (add/remove/exchange) (#264) New method Builder.Add for adding components with a target to entities (#264) New method Batch.SetRelation for batch-setting entity relations (#265) New methods Builder.AddQ, Builder.RemoveQ etc. to get a query over batch-processed entities (#297) Sends an EntityEvent to the world listener on relation target changes (#265) Performance Reduce memory footprint of archetypes by moving properties to nodes (#237) Queries iterate archetype graph nodes in an outer loop, potentially skipping nested relation archetypes (#248) Relation archetypes are recycled in archetype graph nodes (#248) Already empty archetypes are not zeroed on reset (#248) Optimize RelationFilter: get archetype directly instead of iterating complete node (#251) Cached filters use swap-remove when removing an archetype (#253) Speed up generic query re-compilation after changing the relation target (#255) Speed up archetype and node iteration to be as fast as before the new nested structure (#270, #288) Filter cache stores archetype graph nodes instead of archetypes (#276) (#288) Use uint32 instead of uintptr for indices and query iteration counter (#283) Cached filters use a map for faster removal of archetypes (#289) Speed up iterating through many archetypes by approx. 10% (#301) Documentation Adds an example for creating and querying entity relations (#256) Adds a section on entity relations to the ARCHITECTURE.md document (#256) Replace Aos benchmarks plot in README for pointer iteration fix #284 (#285) Adds a plot for entity relation benchmarks to ARCHITECTURE.md (#290) Adds an outline of the most important types and functions to each sub-package (#295) Other Remove go-gameengine-ecs from Arche benchmarks (but not from competition!) (#228) Reduce memory size of Query and internal archetype list by 8 bytes (#230) Generic filters are locked when registered for caching (#241) Adds benchmarks for getting and setting entity relations (#259) Arche now has an official logo (#273) Use for loop with counter in AoS competition benchmarks, to allow for pointers (#284) [v0.7.1] Documentation Tweak/improve example batch_ops (#222) Adds an example for running simulations in parallel (#223) Other Adds benchmarks for world component access with shuffled entities (#224) [v0.7.0] Features Adds method World.ComponentType(ID) to get the reflect.Type for component IDs (#215) Adds methods World.GetUnchecked and World.HasUnchecked as optimized variants for known static entities (#217, #219) Adds method MapX.GetUnchecked to all generic mappers, as equivalent to previous point (#217, #219) Adds methods Map.GetUnchecked and Map.HasUnchecked to generic Map, as equivalent to previous points (#217, #219) Performance Optimize World.Alive(Entity) by only checking the entity generation, but not id == 0 (#220) Bugfixes All world methods with an entity as argument panic on a dead/recycled entity; causes 0.5ns slower World.Get(Entity) (#216) [v0.6.3] Documentation Minor README and docstring tweaks (#211, #213) Other Use coveralls.io for test coverage, add respective badge (#212) [v0.6.2] Performance Speed up generating world stats by factor 10, by re-using stats object (#210) [v0.6.1] Documentation Extend documentation and benchmarks for Entity (#201) Add a section with links to the Arche tools arche-model and arche-pixel (#202) [v0.6.0] Arche v0.6.0 features fast batch entity creation and deletion, cached filters, and many internal optimizations.\nHighlights Batch creation and deletion of entities, with up to 4x and 10x speedup, respectively. Even more when combined with World.Reset(). Cached filters for handling many archetypes and complex queries without slowdown. A lot of internal performance optimizations. Breaking changes Generic mappers do no longer return all components when creating entities or components (#145) Resources API moved out of the world, to a helper to get by World.Resources() (#150) World.Reset() does no longer remove the component change listener (#157) Removes methods filter.ALL.Not() and filter.ANY.Not(), use NoneOf() and AnyNot() instead (#160) World listener function takes a pointer to the EntityEvent instead of a copy as argument (#162) Features Adds method World.Reset(), to allow for more efficient systematic simulations (#138) Adds World.Batch() helper for performing optimized batch-creation and batch-removal of entities (#149) Adds method Mask.Exclusive() to create a filter matching an exact component composition (#149, #188) Generic mappers (Map1, …) have methods NewEntities, NewEntitiesWith and RemoveEntities for batch operations (#151) Batch-creation methods (ID-based and generic) have variants like NewEntitiesQuery that return a query over the created entities (#152) Notification during batch-creation is delayed until the resp. query is closed (#157) Batch-remove methods (RemoveEntities()) return the number of removed entities (#173) Filters can be cached and tracked by the World to speed up queries when there are many archetypes (#178) Function AddResource[T](*World) returns the ID of the resource (#183) Performance Speedup of archetype mask checks by 10% by checking mask before empty archetype (#139) Speedup of generic queries and mappers to come closer to ID-based access (#144) Speedup of archetype mask checks by casting filter interface to concrete type when possible (#148) Optimized batch creation of entities (#159) More efficiently clear the memory of removed components, with 2-3x speedup (#165) Do not clear memory when adding entities to archetypes, not required anymore as of #147 (#165) Speed up copying entity to archetype by getting entity pointer without reflection (#166) Avoid slice allocations in generic mapper methods (#170) Avoid type checks in query when iterating archetypes (#179) Speed up counting entities in queries with a cached filter (#182) Implements a fast and memory-efficient lookup data structure for components ID keys, to reduce the memory footprint of archetypes and the archetype graph (#192) Speedup of archetype creation by 40% by using a const for archetype storage page sizes (#197) Bugfixes Archetype storage buffers are “zeroed” when removing entities, to allow GC on pointers and slices in components (#147) Use slices instead of arrays inside paged archetype list to ensure pointer persistence (#184) Documentation Adds an example for batch-creation and batch-removal of entities (#173) Adds code examples to most public types, methods and functions (#183, #189) Other Restructure and extend benchmarks (#146, #153, #155, #156) Add an ECS competition benchmark for adding and removing components (#170) Add benchmarks for different ways to implement parent-child relations between entities (#194, #195) [v0.5.1] Performance Speedup of archetype access by 5-10% by merging storages into archetypes (#137) Documentation Document all private functions, types and methods (#136) Adds a section and plot on benchmarks against other Go ECS implementations to the README (#138) Other Internal code refactoring (#136) Move method nextArchetype from World to Query. Remove internal type queryIter. Move repetitive pointer copying code in storage into a private method. Move repetitive entity creation code in World into a private method. [v0.5.0] Feature release. Does not break v0.4.x projects.\nFeatures The World handles ECS resources, i.e. component-like global data (#132) Generic access to world resources (#132) Documentation Adds an example for the use of resources (#132) [v0.4.6] Performance Speedup archetype access by 10%, by elimination of bounds checks (#126) Speedup entity access from queries by 50% by using a component storage for them (#131) Minor optimizations of component storage (#128) Documentation Adds an example to demonstrate how to implement classical ECS systems (#129) [v0.4.5] Features Adds memory per entity to archetype stats (#124) Other Adds benchmarks of Arche vs. Array of Structs (AoS) and Array of Pointers (AoP), for different memory per entity and number of entities (#123) [v0.4.4] Features Query has methods Count() and Step(int), primarily for effective random sampling (#119) Documentation Adds example random_sampling to demonstrate usage of Query.Count() and Query.Step(int) (#119) Bugfixes Query.Next, Query.Get, etc. now always panic when called on a closed query (#117) Other Update to go-gameengine-ecs v0.9.0 in benchmarks (#116) Remove internal wrapper structs in generic queries and maps (#120) [v0.4.3] Bugfixes EntityEvent has more consistent values when an entity is removed (#115) EntityEvent.NewMask is zero EntityEvent.Removed is contains all former components EntityEvent.Current is nil [v0.4.2] Performance Avoid creation of unused archetypes by splitting the archetype graph out of the actual archetypes (#113) Use slice instead of fixed-size array for type lookup in component registry (#113) Avoid copying entityIndex structs by using pointers (#114) [v0.4.1] Bugfixes Fix units symbol for bytes from b to B in string formatting of world statistics (#111) Other Adds github.com/wfranczyk/ento to benchmarks (#110) [v0.4.0] API revision, split out generics and filters into separate packages.\nFeatures Generic queries support optional, additional and excluded components (#53, #56, #58, #59, #60, #63) Logic filters for complex queries (#54, #58, #61) Query and World have a method Mask(Entity) to access archetype masks (#65) Generic query Get method returns all queried components (#83) Added method World.Stats() for inspecting otherwise inaccessible world statistics (#67) Entities can be initialized with components, via ID as well as using generics (#76) A listener function can be registered to the world, for notification on entity changes (#77) Support for up to 128 distinct component types per world (was limited to 64 before) (#78) Generic entity manipulation through types Map1, Map2, … and Exchange (#79, #84, #87) Performance Generic queries are compiled to masks and cached on first build (#62) Optimization of adding/removing components, with 2-3x speedup and vast reduction of (number of) allocations (#93) Speed up component world access by use of nil pointer check instead of bitmask (#96) Other Overhaul of the module structure, with generics and filters in separate packages (#55, #57, #61, #64) Boilerplate code for generic filters and queries is auto-generated with go generate (#64) Ensure 100% test coverage by adding a CI check for it (#68) World.RemEntity(Entity) is now World.RemoveEntity(Entity) (#87) More examples as user documentation (#83, #95) General API cleanup with renaming of several types and methods (#100) [v0.3.1] Other Fix failing https://pkg.go.dev to fetch Arche version v0.3.0 [v0.3.0] Features Added a layer of generic access as alternative for using component IDs, for type safety and ergonomics (#47, #48) Generic queries like Query1[T], Query2[T, U], … (#47) Generic add, assign and remove (Add[T](), Add2[T, U](), ...) (#47) Generic get, has, and set through component mapper Map[T] (#47) Performance Use of an archetype graph to speed up finding the target archetype for component addition/removal (#42) Minor optimization of component access by queries (#50) Other Reduced dependencies by moving profiling and benchmarking to sub-modules (#46) Smaller integer type for component identifiers (#47) [v0.2.0] Features World has method Exchange to add and remove components in one go (#38) World has method Assign add and assign components in one go (#38) World has method AssignN add and assign multiple components in one go (#38) Performance Optimization of Query iteration, avoids allocations and makes it approx. 30% faster (#35) Much smaller archetype data structure at the cost of one more index lookup (#37) Other Removed method Query.Count(), as it was a by-product of the allocations in the above point (#35) Archetypes are stored in a paged collection to use more efficient access by pointers (#36) [v0.1.4] Documentation Extended and improved documentation (#34) [v0.1.3] Features Add Config to allow for configuration of the world (currently only storage capacity increment) (#28) Query has a method Count(), reporting the total number of matching entities (#30) [v0.1.2] Other Use aligned item size in component storage for faster query iteration (#25) Queries lock the World, and automatically unlock it after iteration (#26) [v0.1.1] Other Avoid allocation in World.Has(entity, compID) (#16) World.RemEntity(entity) panics on dead entity, like all other World methods (#18) Reserve zero value Entity to serve as nil/undefined value (#23) [v0.1.0] Initial release.\nBasic ECS implementation.","v0110httpsgithubcommlange-42archecomparev0101v0110#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.10.1...v0.11.0\"\u003e[v0.11.0]\u003c/a\u003e":"","v011httpsgithubcommlange-42archecomparev010v011#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.0...v0.1.1\"\u003e[v0.1.1]\u003c/a\u003e":"","v0120httpsgithubcommlange-42archecomparev0110v0120#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.11.0...v0.12.0\"\u003e[v0.12.0]\u003c/a\u003e":"","v012httpsgithubcommlange-42archecomparev011v012#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.1...v0.1.2\"\u003e[v0.1.2]\u003c/a\u003e":"","v0130httpsgithubcommlange-42archecomparev0120v0130#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.12.0...v0.13.0\"\u003e[v0.13.0]\u003c/a\u003e":"","v0131httpsgithubcommlange-42archecomparev0130v0131#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.0...v0.13.1\"\u003e[v0.13.1]\u003c/a\u003e":"","v0132httpsgithubcommlange-42archecomparev0131v0132#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.1...v0.13.2\"\u003e[v0.13.2]\u003c/a\u003e":"","v0133httpsgithubcommlange-42archecomparev0132v0133#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.2...v0.13.3\"\u003e[v0.13.3]\u003c/a\u003e":"","v013httpsgithubcommlange-42archecomparev012v013#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.2...v0.1.3\"\u003e[v0.1.3]\u003c/a\u003e":"","v0140httpsgithubcommlange-42archecomparev0133v0140#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.3...v0.14.0\"\u003e[v0.14.0]\u003c/a\u003e":"","v0141httpsgithubcommlange-42archecomparev0140v0141#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.0...v0.14.1\"\u003e[v0.14.1]\u003c/a\u003e":"","v0142httpsgithubcommlange-42archecomparev0141v0142#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.1...v0.14.2\"\u003e[v0.14.2]\u003c/a\u003e":"","v0143httpsgithubcommlange-42archecomparev0142v0143#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.2...v0.14.3\"\u003e[v0.14.3]\u003c/a\u003e":"","v0144httpsgithubcommlange-42archecomparev0143v0144#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.3...v0.14.4\"\u003e[v0.14.4]\u003c/a\u003e":"","v0145httpsgithubcommlange-42archecomparev0144v0145#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.4...v0.14.5\"\u003e[v0.14.5]\u003c/a\u003e":"","v014httpsgithubcommlange-42archecomparev013v014#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.3...v0.1.4\"\u003e[v0.1.4]\u003c/a\u003e":"","v0150httpsgithubcommlange-42archecomparev0145v0150#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.5...v0.15.0\"\u003e[v0.15.0]\u003c/a\u003e":"","v0151httpsgithubcommlange-42archecomparev0150v0151#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.15.0...v0.15.1\"\u003e[v0.15.1]\u003c/a\u003e":"","v0152httpsgithubcommlange-42archecomparev0151v0152#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.15.1...v0.15.2\"\u003e[v0.15.2]\u003c/a\u003e":"","v0153httpsgithubcommlange-42archecomparev0152v0153#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.15.2...v0.15.3\"\u003e[v0.15.3]\u003c/a\u003e":"","v020httpsgithubcommlange-42archecomparev014v020#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.4...v0.2.0\"\u003e[v0.2.0]\u003c/a\u003e":"","v030httpsgithubcommlange-42archecomparev020v030#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.2.0...v0.3.0\"\u003e[v0.3.0]\u003c/a\u003e":"","v031httpsgithubcommlange-42archecomparev030v031#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.3.0...v0.3.1\"\u003e[v0.3.1]\u003c/a\u003e":"","v040httpsgithubcommlange-42archecomparev031v040#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.3.1...v0.4.0\"\u003e[v0.4.0]\u003c/a\u003e":"","v041httpsgithubcommlange-42archecomparev040v041#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.0...v0.4.1\"\u003e[v0.4.1]\u003c/a\u003e":"","v042httpsgithubcommlange-42archecomparev041v042#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.1...v0.4.2\"\u003e[v0.4.2]\u003c/a\u003e":"","v043httpsgithubcommlange-42archecomparev042v043#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.2...v0.4.3\"\u003e[v0.4.3]\u003c/a\u003e":"","v044httpsgithubcommlange-42archecomparev043v044#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.3...v0.4.4\"\u003e[v0.4.4]\u003c/a\u003e":"","v045httpsgithubcommlange-42archecomparev044v045#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.4...v0.4.5\"\u003e[v0.4.5]\u003c/a\u003e":"","v046httpsgithubcommlange-42archecomparev045v046#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.5...v0.4.6\"\u003e[v0.4.6]\u003c/a\u003e":"","v050httpsgithubcommlange-42archecomparev046v050#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.6...v0.5.0\"\u003e[v0.5.0]\u003c/a\u003e":"","v051httpsgithubcommlange-42archecomparev050v051#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.5.0...v0.5.1\"\u003e[v0.5.1]\u003c/a\u003e":"","v060httpsgithubcommlange-42archecomparev051v060#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.5.1...v0.6.0\"\u003e[v0.6.0]\u003c/a\u003e":"","v061httpsgithubcommlange-42archecomparev060v061#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.0...v0.6.1\"\u003e[v0.6.1]\u003c/a\u003e":"","v062httpsgithubcommlange-42archecomparev061v062#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.1...v0.6.2\"\u003e[v0.6.2]\u003c/a\u003e":"","v063httpsgithubcommlange-42archecomparev062v063#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.2...v0.6.3\"\u003e[v0.6.3]\u003c/a\u003e":"","v070httpsgithubcommlange-42archecomparev063v070#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.3...v0.7.0\"\u003e[v0.7.0]\u003c/a\u003e":"","v071httpsgithubcommlange-42archecomparev070v071#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.7.0...v0.7.1\"\u003e[v0.7.1]\u003c/a\u003e":"","v080httpsgithubcommlange-42archecomparev071v080#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.7.1...v0.8.0\"\u003e[v0.8.0]\u003c/a\u003e":"","v081httpsgithubcommlange-42archecomparev080v081#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.8.0...v0.8.1\"\u003e[v0.8.1]\u003c/a\u003e":"","v090httpsgithubcommlange-42archecomparev081v090#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.8.1...v0.9.0\"\u003e[v0.9.0]\u003c/a\u003e":""},"title":"Changelog"},"/arche/background/design/":{"data":{"":"Unlike most other ECS implementations, Arche is designed for the development of scientific,\nindividual-based models rather than for game development.\nThis motivates some design decisions, with an emphasis on simplicity, safety and performance.\nNevertheless, Arche can also be used for game development.","determinism#Determinism":"Iteration order in Arche is deterministic and reproducible. This does not mean that entities are iterated in their order of insertion, nor in the same order in successive iterations. However, given the same operations on the ecs.World, iteration order will always be the same.","limitations#Limitations":" The number of component types per World is limited to 256. This is mainly a performance decision. The number of entities alive at any one time is limited to just under 5 billion (uint32 ID). ","simple-core-api#Simple core API":"The ecs.World object is a pure and simple ECS implementation in the sense of a data store for entities and components, with query and iteration capabilities. More advanced features like batch operations or entity relations are provided through separate objects.\nThere is neither an update loop nor systems. These should be implemented by the user. For a batteries-included implementation, see module arche-model.\nThe type-safe generic API and advanced logic filters are provided in the packages generic and filter, respectively. Both packages are built on top of the core ecs package, so they could also be implemented by a user.","strict-and-panic#Strict and panic":"Arche puts an emphasis on safety and on avoiding undefined behavior.\nIt panics on unexpected operations, like removing a dead entity,\nadding a component that is already present, or attempting to change a locked world.\nThis may not seem idiomatic for Go.\nHowever, explicit error handling in performance hot spots is not an option.\nNeither is silent failure, given the scientific background."},"title":"Design Philosophy"},"/arche/generated/_benchmarks/":{"data":{"":"Last run: Tue, 01 Apr 2025 08:46:24 UTC\nVersion: Arche v0.15.3\nCPU: AMD EPYC 7763 64-Core Processor","components#Components":" Operation Time Remark World.Add 1 Comp 41.4 ns memory already alloc. World.Add 5 Comps 71.6 ns memory already alloc. World.Add 1 to 5 Comps 114.0 ns memory already alloc. World.Remove 1 Comp 50.9 ns memory already alloc. World.Remove 5 Comps 110.1 ns memory already alloc. World.Remove 1 of 5 Comps 107.3 ns memory already alloc. World.Exchange 1 Comp 59.1 ns memory already alloc. World.Exchange 1 of 5 Comps 112.6 ns memory already alloc. Map1.Assign 1 Comps 48.1 ns memory already alloc. Map5.Assign 5 Comps 97.7 ns memory already alloc. ","components-batched#Components, batched":" Operation Time Remark Batch.Add 1 Comp 4.3 ns 1000, memory already allocated Batch.Add 5 Comps 4.4 ns 1000, memory already allocated Batch.Add 1 to 5 Comps 7.9 ns 1000, memory already allocated Batch.Remove 1 Comp 4.5 ns 1000, memory already allocated Batch.Remove 5 Comps 5.8 ns 1000, memory already allocated Batch.Remove 1 of 5 Comps 7.0 ns 1000, memory already allocated Batch.Exchange 1 Comp 4.6 ns 1000, memory already allocated Batch.Exchange 1 of 5 Comps 7.0 ns 1000, memory already allocated ","entities#Entities":" Operation Time Remark Entity.IsZero 0.2 ns World.NewEntity 17.2 ns memory already alloc. World.NewEntity w/ 1 Comp 24.1 ns memory already alloc. World.NewEntity w/ 5 Comps 47.0 ns memory already alloc. World.RemoveEntity 16.2 ns World.RemoveEntity w/ 1 Comp 27.7 ns World.RemoveEntity w/ 5 Comps 60.5 ns Map1.NewWith 1 Comp 31.4 ns memory already alloc. Map5.NewWith 5 Comps 72.9 ns memory already alloc. ","entities-batched#Entities, batched":" Operation Time Remark Batch.New 9.6 ns 1000, memory already allocated Batch.New w/ 1 Comp 9.9 ns 1000, memory already allocated Batch.New w/ 5 Comps 9.7 ns 1000, memory already allocated Batch.RemoveEntities 7.1 ns 1000 Batch.RemoveEntities w/ 1 Comp 7.6 ns 1000 Batch.RemoveEntities w/ 5 Comps 8.7 ns 1000 ","other#Other":" Operation Time Remark ecs.NewWorld 6.7 μs World.Reset 80.0 ns empty world ecs.ComponentID 22.1 ns component already registered ","query#Query":" Operation Time Remark Query.Next 1.0 ns Query.Next + 1x Query.Get 1.7 ns Query.Next + 2x Query.Get 1.9 ns Query.Next + 5x Query.Get 4.5 ns Query.Next + Query.Entity 1.7 ns Query.Next + Query.Relation 2.3 ns Query.EntityAt, 1 arch 12.0 ns Query.EntityAt, 1 arch 3.2 ns registered filter Query.EntityAt, 5 arch 30.8 ns Query.EntityAt, 5 arch 5.0 ns registered filter World.Query 30.5 ns World.Query 34.9 ns registered filter ","world-access#World access":" Operation Time Remark World.Get 2.1 ns random, 1000 entities World.GetUnchecked 1.5 ns random, 1000 entities World.Has 1.2 ns random, 1000 entities World.HasUnchecked 0.7 ns random, 1000 entities World.Alive 0.4 ns random, 1000 entities World.Relations.Get 3.4 ns random, 1000 entities World.Relations.GetUnchecked 0.8 ns random, 1000 entities "},"title":"_benchmarks"},"/arche/generated/_changelog/":{"data":{"":"","v0100httpsgithubcommlange-42archecomparev090v0100#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.9.0...v0.10.0\"\u003e[v0.10.0]\u003c/a\u003e":"","v0101httpsgithubcommlange-42archecomparev0100v0101#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.10.0...v0.10.1\"\u003e[v0.10.1]\u003c/a\u003e":"","v010httpsgithubcommlange-42archetreev010#\u003ca href=\"https://github.com/mlange-42/arche/tree/v0.1.0\"\u003e[v0.1.0]\u003c/a\u003e":"[v0.15.3] Performance Avoids heap allocations in generic MapX by using arrays for IDs (#478) Documentation Migrates the user guide to the Hextra theme (#488, #489) [v0.15.2] Performance Speeds up reset of small archetypes by zeroing memory manually (#475) [v0.15.1] Performance Optimizes batch operations (add, remove, exchange) by bulk-copying components (#473) Documentation Adds benchmarks to the user guide for 1-of-5 components operations (e.g. remove 1 of 5) (#474) [v0.15.0] Arche v0.15.0 features optimizations that vastly speed up the creation of huge numbers (millions) of entities. Namely, all memory is grown exponentially now, rather than linearly. This also causes a breaking change, as the former “capacity increments” turned into just initial capacities.\nFurther, the README was revised and the ECS competition benchmarks were extended and moved to the go-ecs-benchmarks repository.\nBreaking changes Removes ecs.Config; the world is configured with initial capacities directly (#467) Features Adds methods Batch.New and Batch.NewQ for batch entity creation (#468) Deprecates ecs.Component, as a followup of deprecation of all methods that use it (#470) Performance Optimizes entity creation by an altered growth policy for archetypes, entity list and entity pool (#464, #466, #469) Documentation Rewrites features and benchmarks sections of the README (#462) Adds version and CPU information to the benchmarks in the user guide (#462) Removed deprecated methods from the benchmarks in the user guide (#462) Adds world creation and component ID lookup to the benchmarks in the user guide (#462) Uses the new methods Batch.New and Batch.NewQ in examples where applicable, instead of Builder (#470) Other Uses mask pointers in all tests and benchmarks (#460) [v0.14.5] Documentation Adds notes on entity and component pointer usage to docs and the user guide (#455) Improves sub-package documentation for navigation and findability (#457) [v0.14.4] Performance Optimizes mask to types conversion, speeding up archetype creation by up to 150ns (#453) [v0.14.3] Performance Avoids a bitmask heap escape in world component operations (add, remove, exchange, …), with around 20ns improvement (#452) [v0.14.2] Performance Optimizes MapX.Assign and MapX.NewWith by use of World.GetUnchecked (#449) Documentation Fixes method names and ordering in benchmark tables (#448) Documents listener notification handling in MapX.NewWith (#450) Bugfixes Fixes missing listener notification in MapX.NewWith when called with a relation target (#450) [v0.14.1] Features Adds World.NewEntityFn, World.AddFn and World.ExchangeFn that call a callback function before listener notification (#445) Bugfixes Fixes generic MapX.Assign and MapX.NewWith notifying listeners before setting components (#445, issue #443) Documentation Removes references to deprecated methods from the user guide (#447) Other Retract version v0.14.0 due to issue #443 and required features (#446) [v0.14.0] Features Slow assignment methods like World.Assign and World.NewEntityWith are deprecated, in favour of their now faster generic counterparts (#441) Performance Optimizes Map.Set, MapX.Assign and MapX.NewWith, by not using runtime reflection (#440) Documentation Adds benchmarks for World.Assign and World.NewEntityWith to the user guide (#438) Adds benchmarks for MapX.Assign and MapX.NewWith to the user guide (#440) Bugfixes Prevents garbage collection of slices and pointers in components added via World.Assign and similar methods (#438, issue #437) Known issues Generic MapX.Assign and MapX.NewWith notify listeners before setting components (#443) [v0.13.3] Performance Simplifies the archetype graph to use only a single list of neighbors per node, saving a bit of memory (#433) Documentation Adds an example for World.Mask, showing how to check whether a filter “contains” an entity (#428) Adds the beecs implementation of BEEHAVE to the showcase (#429) [v0.13.2] Bugfixes Ensure Assign() copies components before notifying listeners (#426, g-getsov) [v0.13.1] Bugfixes Fixes dispatch listener bug that did not clear component restriction (#424, g-getsov) [v0.13.0] Features Adds function ResourceTypeID to register/get a resource ID from a reflect.Type (#420) Other Fix component type in examples/base (#419) [v0.12.0] Features Adds Entity.ID() and Entity.Generation() (#408, delaneyj) Documentation Adds a showcase chapter “Made with Arche” to the documentation page (#411) Performance Re-arrange struct fields to save memory in a few places (#413) Bugfixes Fix crash caused by extending layouts of an inactive archetype (#416, reported in #415) First-time contributors delaneyj [v0.11.0] Highlights Arche now has a dedicated documentation site with a structured user guide and background information. We hope that this will lower the barrier to entrance significantly.\nFurther, Arche got a few new features:\nQuery.EntityAt was added for random access to query entities. Generic filters now support Exclusive, like ID-based filters. Build tag debug improves error messages in a few places where we rely on standard library panics for performance. Breaking changes Renames types in ecs.stats to follow Go standards. stats.WorldStats -\u003e stats.World, stats.NodeStats -\u003e stats.Node, … (#388) Features Adds method Query.EntityAt(), useful for things like random sampling of entities (#358) Adds build tag debug to improve error messages in a few places where we rely on standard library panics for performance (#377) Adds method FilterX.Exclusive() to all generic filters (#381) Documentation Adds a dedicated Arche User Guide web site (#380, #382, #383, #384, #385) Adds BENCHMARKS.md benchmarks for a tabular overview of the runtime cost of typical Arche ECS operations (#367, #372) Link benchmarking code in README.md and benchmarking tables (#375) Documents build tags tiny and debug in package docs of ecs (#377) Adds examples to demonstrate the use of non-ECS data structures together with ECS (#379) Bugfixes Prevents using the same component multiple times in any operations, through panic (#357) Performance Generic filters use Mask instead of slower MaskFilter if no components are excluded (#381) Other Improves error messages for running out of world locks, components or resources, and on unbalanced unlock (#363) Adds benchmarks for query creation (#366) Upgrade to Go 1.22 in CI (#376) Renames directory examples to _examples to accommodate changed test coverage behaviour of Go 1.22 (#376) In unit tests, error messages of all panics are asserted (#377) [v0.10.1] Bugfixes Fix IsRelation check to allow for non-struct components, like type aliases (#354) Other Repository arche-demo provides a live demo of several models built with Arche. [v0.10.0] Highlights Arche supports full world serialization and deserialization, in conjunction with arche-serde (#319) Supports 256 instead of 128 component types as well as resource types and engine locks (#313) Generic API supports up to 12 instead of 8 component types (#324) Reworked event system with granular subscription to different event types and components (#333, #334, #335, #337, #340) Breaking changes MaskTotalBits changed from 128 to 256 (#313) Removes Mask.Lo and Mask.Hi, internal mask representation is now private (#313) Filter.Matches(Mask) became Filter.Matches(*Mask); same for all Filter implementations (#313)\nThis change was necessary to get the same performance as before, despite the more heavyweight implementation of the now 256 bits Mask. Component and resource IDs are now opaque types instead of type aliases for uint8 (#330) Restructures EntityEvent to remove redundant information and better handle relation changes (#333) World event listener changed from a simple function to a Listener interface (#334) Removes World.ComponentType(ID), use function ComponentInfo(ID) instead (#341) Features Adds functions ComponentInfo(*World, ID) and ResourceType(*World, ResID) (#315, #318) Adds methods World.Ids(Entity) and Query.Ids() to get component IDs for an entity (#315, #325) Entities support JSON marshalling and unmarshalling (#319) The world’s entity state can be extracted and re-established via World.DumpEntities() and World.LoadEntities() (#319, #326) Adds functions ComponentIDs(*World) and ResourceIDs(*World) to get all registered IDs (#330) Adds methods Mask.And, Mask.Or and Mask.Xor (#335) Adds build tag tiny to restrict to 64 components for an extra bit of performance (#338) Adds methods Relations.Exchange(), Relations.ExchangeBatch(), Relations.ExchangeBatchQ() for exchange with relation target (#342) Generic API adds Exchange.WithRelation() and optional target argument for operations with relation target (#342) Generic API adds MapX.AddBatch(), MapX.AddBatchQ(), MapX.RemoveBatch()and MapX.RemoveBatchQ() (#342) Generic API adds optional relation target argument to most MapX methods (#342) Generic API adds FilterX.Filter() to get an ecs.Filter from a generic one (#342) Generic API adds Map.SetRelationBatch() and Map.SetRelationBatchQ() (#344) All batch operations (except entity creation) return the number of affected entities (#348) Performance Reduces archetype memory footprint by using a dynamically sized slice for storage lookup (#327) Reduces event listener overhead through granular subscriptions and elimination of a heap allocation (#333, #334, #335, #337, #340) Documentation Adds an overview to packages ecs and generic on how to achieve ECS manipulation operations (#345) Other Entity generation data type changed from uint16 to uint32 (#317) Adds unitoftime/ecs to competition benchmarks (#311) Adds competition benchmarks for accessing 10 components (#328) [v0.9.0] Infrastructure Upgraded to Go 1.21 toolchain (#308) [v0.8.1] Documentation Emphasize in Entity and World docs that entities are intended to be stored and passed by copy, not by pointer (#306) [v0.8.0] Highlights Entity relations were added as a first-class feature (#231, #271)\nRelations are used to represent graphs of entities, e.g. hierarchies. They can be added, removed and queried just like normal components. The new feature offers ergonomic handling of entity relations, and provides relation queries with native performance.\nBreaking changes Removed World.Batch for entity batch creation, use Builder instead (#239) Rework of generic entity creation API, use MapX.New, MapX.NewWith, MapX.NewBatch and MapX.NewQuery (#239, #252) Stats object WorldStats etc. adapted for new structure of archetypes nested in nodes (#258) Removed generic filter method FilterX.Filter (#271) Method Batch.NewQuery renamed to Batch.NewBatchQ (#298) Features Relation archetypes are removed when they are empty and the target entity is dead (#238, #242) Support an unlimited number of cached filters, instead of 128 (#245) WorldStats contains the number of cached filters (#247) Archetypes with entity relations are removed on World.Reset (#247) Capacity increment can be configured separately for relation archetypes (#257) Adds methods for faster, unchecked entity relation access (#259) Re-introduce World.Batch for batch-processing of entities (add/remove/exchange) (#264) New method Builder.Add for adding components with a target to entities (#264) New method Batch.SetRelation for batch-setting entity relations (#265) New methods Builder.AddQ, Builder.RemoveQ etc. to get a query over batch-processed entities (#297) Sends an EntityEvent to the world listener on relation target changes (#265) Performance Reduce memory footprint of archetypes by moving properties to nodes (#237) Queries iterate archetype graph nodes in an outer loop, potentially skipping nested relation archetypes (#248) Relation archetypes are recycled in archetype graph nodes (#248) Already empty archetypes are not zeroed on reset (#248) Optimize RelationFilter: get archetype directly instead of iterating complete node (#251) Cached filters use swap-remove when removing an archetype (#253) Speed up generic query re-compilation after changing the relation target (#255) Speed up archetype and node iteration to be as fast as before the new nested structure (#270, #288) Filter cache stores archetype graph nodes instead of archetypes (#276) (#288) Use uint32 instead of uintptr for indices and query iteration counter (#283) Cached filters use a map for faster removal of archetypes (#289) Speed up iterating through many archetypes by approx. 10% (#301) Documentation Adds an example for creating and querying entity relations (#256) Adds a section on entity relations to the ARCHITECTURE.md document (#256) Replace Aos benchmarks plot in README for pointer iteration fix #284 (#285) Adds a plot for entity relation benchmarks to ARCHITECTURE.md (#290) Adds an outline of the most important types and functions to each sub-package (#295) Other Remove go-gameengine-ecs from Arche benchmarks (but not from competition!) (#228) Reduce memory size of Query and internal archetype list by 8 bytes (#230) Generic filters are locked when registered for caching (#241) Adds benchmarks for getting and setting entity relations (#259) Arche now has an official logo (#273) Use for loop with counter in AoS competition benchmarks, to allow for pointers (#284) [v0.7.1] Documentation Tweak/improve example batch_ops (#222) Adds an example for running simulations in parallel (#223) Other Adds benchmarks for world component access with shuffled entities (#224) [v0.7.0] Features Adds method World.ComponentType(ID) to get the reflect.Type for component IDs (#215) Adds methods World.GetUnchecked and World.HasUnchecked as optimized variants for known static entities (#217, #219) Adds method MapX.GetUnchecked to all generic mappers, as equivalent to previous point (#217, #219) Adds methods Map.GetUnchecked and Map.HasUnchecked to generic Map, as equivalent to previous points (#217, #219) Performance Optimize World.Alive(Entity) by only checking the entity generation, but not id == 0 (#220) Bugfixes All world methods with an entity as argument panic on a dead/recycled entity; causes 0.5ns slower World.Get(Entity) (#216) [v0.6.3] Documentation Minor README and docstring tweaks (#211, #213) Other Use coveralls.io for test coverage, add respective badge (#212) [v0.6.2] Performance Speed up generating world stats by factor 10, by re-using stats object (#210) [v0.6.1] Documentation Extend documentation and benchmarks for Entity (#201) Add a section with links to the Arche tools arche-model and arche-pixel (#202) [v0.6.0] Arche v0.6.0 features fast batch entity creation and deletion, cached filters, and many internal optimizations.\nHighlights Batch creation and deletion of entities, with up to 4x and 10x speedup, respectively. Even more when combined with World.Reset(). Cached filters for handling many archetypes and complex queries without slowdown. A lot of internal performance optimizations. Breaking changes Generic mappers do no longer return all components when creating entities or components (#145) Resources API moved out of the world, to a helper to get by World.Resources() (#150) World.Reset() does no longer remove the component change listener (#157) Removes methods filter.ALL.Not() and filter.ANY.Not(), use NoneOf() and AnyNot() instead (#160) World listener function takes a pointer to the EntityEvent instead of a copy as argument (#162) Features Adds method World.Reset(), to allow for more efficient systematic simulations (#138) Adds World.Batch() helper for performing optimized batch-creation and batch-removal of entities (#149) Adds method Mask.Exclusive() to create a filter matching an exact component composition (#149, #188) Generic mappers (Map1, …) have methods NewEntities, NewEntitiesWith and RemoveEntities for batch operations (#151) Batch-creation methods (ID-based and generic) have variants like NewEntitiesQuery that return a query over the created entities (#152) Notification during batch-creation is delayed until the resp. query is closed (#157) Batch-remove methods (RemoveEntities()) return the number of removed entities (#173) Filters can be cached and tracked by the World to speed up queries when there are many archetypes (#178) Function AddResource[T](*World) returns the ID of the resource (#183) Performance Speedup of archetype mask checks by 10% by checking mask before empty archetype (#139) Speedup of generic queries and mappers to come closer to ID-based access (#144) Speedup of archetype mask checks by casting filter interface to concrete type when possible (#148) Optimized batch creation of entities (#159) More efficiently clear the memory of removed components, with 2-3x speedup (#165) Do not clear memory when adding entities to archetypes, not required anymore as of #147 (#165) Speed up copying entity to archetype by getting entity pointer without reflection (#166) Avoid slice allocations in generic mapper methods (#170) Avoid type checks in query when iterating archetypes (#179) Speed up counting entities in queries with a cached filter (#182) Implements a fast and memory-efficient lookup data structure for components ID keys, to reduce the memory footprint of archetypes and the archetype graph (#192) Speedup of archetype creation by 40% by using a const for archetype storage page sizes (#197) Bugfixes Archetype storage buffers are “zeroed” when removing entities, to allow GC on pointers and slices in components (#147) Use slices instead of arrays inside paged archetype list to ensure pointer persistence (#184) Documentation Adds an example for batch-creation and batch-removal of entities (#173) Adds code examples to most public types, methods and functions (#183, #189) Other Restructure and extend benchmarks (#146, #153, #155, #156) Add an ECS competition benchmark for adding and removing components (#170) Add benchmarks for different ways to implement parent-child relations between entities (#194, #195) [v0.5.1] Performance Speedup of archetype access by 5-10% by merging storages into archetypes (#137) Documentation Document all private functions, types and methods (#136) Adds a section and plot on benchmarks against other Go ECS implementations to the README (#138) Other Internal code refactoring (#136) Move method nextArchetype from World to Query. Remove internal type queryIter. Move repetitive pointer copying code in storage into a private method. Move repetitive entity creation code in World into a private method. [v0.5.0] Feature release. Does not break v0.4.x projects.\nFeatures The World handles ECS resources, i.e. component-like global data (#132) Generic access to world resources (#132) Documentation Adds an example for the use of resources (#132) [v0.4.6] Performance Speedup archetype access by 10%, by elimination of bounds checks (#126) Speedup entity access from queries by 50% by using a component storage for them (#131) Minor optimizations of component storage (#128) Documentation Adds an example to demonstrate how to implement classical ECS systems (#129) [v0.4.5] Features Adds memory per entity to archetype stats (#124) Other Adds benchmarks of Arche vs. Array of Structs (AoS) and Array of Pointers (AoP), for different memory per entity and number of entities (#123) [v0.4.4] Features Query has methods Count() and Step(int), primarily for effective random sampling (#119) Documentation Adds example random_sampling to demonstrate usage of Query.Count() and Query.Step(int) (#119) Bugfixes Query.Next, Query.Get, etc. now always panic when called on a closed query (#117) Other Update to go-gameengine-ecs v0.9.0 in benchmarks (#116) Remove internal wrapper structs in generic queries and maps (#120) [v0.4.3] Bugfixes EntityEvent has more consistent values when an entity is removed (#115) EntityEvent.NewMask is zero EntityEvent.Removed is contains all former components EntityEvent.Current is nil [v0.4.2] Performance Avoid creation of unused archetypes by splitting the archetype graph out of the actual archetypes (#113) Use slice instead of fixed-size array for type lookup in component registry (#113) Avoid copying entityIndex structs by using pointers (#114) [v0.4.1] Bugfixes Fix units symbol for bytes from b to B in string formatting of world statistics (#111) Other Adds github.com/wfranczyk/ento to benchmarks (#110) [v0.4.0] API revision, split out generics and filters into separate packages.\nFeatures Generic queries support optional, additional and excluded components (#53, #56, #58, #59, #60, #63) Logic filters for complex queries (#54, #58, #61) Query and World have a method Mask(Entity) to access archetype masks (#65) Generic query Get method returns all queried components (#83) Added method World.Stats() for inspecting otherwise inaccessible world statistics (#67) Entities can be initialized with components, via ID as well as using generics (#76) A listener function can be registered to the world, for notification on entity changes (#77) Support for up to 128 distinct component types per world (was limited to 64 before) (#78) Generic entity manipulation through types Map1, Map2, … and Exchange (#79, #84, #87) Performance Generic queries are compiled to masks and cached on first build (#62) Optimization of adding/removing components, with 2-3x speedup and vast reduction of (number of) allocations (#93) Speed up component world access by use of nil pointer check instead of bitmask (#96) Other Overhaul of the module structure, with generics and filters in separate packages (#55, #57, #61, #64) Boilerplate code for generic filters and queries is auto-generated with go generate (#64) Ensure 100% test coverage by adding a CI check for it (#68) World.RemEntity(Entity) is now World.RemoveEntity(Entity) (#87) More examples as user documentation (#83, #95) General API cleanup with renaming of several types and methods (#100) [v0.3.1] Other Fix failing https://pkg.go.dev to fetch Arche version v0.3.0 [v0.3.0] Features Added a layer of generic access as alternative for using component IDs, for type safety and ergonomics (#47, #48) Generic queries like Query1[T], Query2[T, U], … (#47) Generic add, assign and remove (Add[T](), Add2[T, U](), ...) (#47) Generic get, has, and set through component mapper Map[T] (#47) Performance Use of an archetype graph to speed up finding the target archetype for component addition/removal (#42) Minor optimization of component access by queries (#50) Other Reduced dependencies by moving profiling and benchmarking to sub-modules (#46) Smaller integer type for component identifiers (#47) [v0.2.0] Features World has method Exchange to add and remove components in one go (#38) World has method Assign add and assign components in one go (#38) World has method AssignN add and assign multiple components in one go (#38) Performance Optimization of Query iteration, avoids allocations and makes it approx. 30% faster (#35) Much smaller archetype data structure at the cost of one more index lookup (#37) Other Removed method Query.Count(), as it was a by-product of the allocations in the above point (#35) Archetypes are stored in a paged collection to use more efficient access by pointers (#36) [v0.1.4] Documentation Extended and improved documentation (#34) [v0.1.3] Features Add Config to allow for configuration of the world (currently only storage capacity increment) (#28) Query has a method Count(), reporting the total number of matching entities (#30) [v0.1.2] Other Use aligned item size in component storage for faster query iteration (#25) Queries lock the World, and automatically unlock it after iteration (#26) [v0.1.1] Other Avoid allocation in World.Has(entity, compID) (#16) World.RemEntity(entity) panics on dead entity, like all other World methods (#18) Reserve zero value Entity to serve as nil/undefined value (#23) [v0.1.0] Initial release.\nBasic ECS implementation.","v0110httpsgithubcommlange-42archecomparev0101v0110#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.10.1...v0.11.0\"\u003e[v0.11.0]\u003c/a\u003e":"","v011httpsgithubcommlange-42archecomparev010v011#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.0...v0.1.1\"\u003e[v0.1.1]\u003c/a\u003e":"","v0120httpsgithubcommlange-42archecomparev0110v0120#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.11.0...v0.12.0\"\u003e[v0.12.0]\u003c/a\u003e":"","v012httpsgithubcommlange-42archecomparev011v012#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.1...v0.1.2\"\u003e[v0.1.2]\u003c/a\u003e":"","v0130httpsgithubcommlange-42archecomparev0120v0130#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.12.0...v0.13.0\"\u003e[v0.13.0]\u003c/a\u003e":"","v0131httpsgithubcommlange-42archecomparev0130v0131#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.0...v0.13.1\"\u003e[v0.13.1]\u003c/a\u003e":"","v0132httpsgithubcommlange-42archecomparev0131v0132#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.1...v0.13.2\"\u003e[v0.13.2]\u003c/a\u003e":"","v0133httpsgithubcommlange-42archecomparev0132v0133#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.2...v0.13.3\"\u003e[v0.13.3]\u003c/a\u003e":"","v013httpsgithubcommlange-42archecomparev012v013#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.2...v0.1.3\"\u003e[v0.1.3]\u003c/a\u003e":"","v0140httpsgithubcommlange-42archecomparev0133v0140#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.13.3...v0.14.0\"\u003e[v0.14.0]\u003c/a\u003e":"","v0141httpsgithubcommlange-42archecomparev0140v0141#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.0...v0.14.1\"\u003e[v0.14.1]\u003c/a\u003e":"","v0142httpsgithubcommlange-42archecomparev0141v0142#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.1...v0.14.2\"\u003e[v0.14.2]\u003c/a\u003e":"","v0143httpsgithubcommlange-42archecomparev0142v0143#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.2...v0.14.3\"\u003e[v0.14.3]\u003c/a\u003e":"","v0144httpsgithubcommlange-42archecomparev0143v0144#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.3...v0.14.4\"\u003e[v0.14.4]\u003c/a\u003e":"","v0145httpsgithubcommlange-42archecomparev0144v0145#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.4...v0.14.5\"\u003e[v0.14.5]\u003c/a\u003e":"","v014httpsgithubcommlange-42archecomparev013v014#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.3...v0.1.4\"\u003e[v0.1.4]\u003c/a\u003e":"","v0150httpsgithubcommlange-42archecomparev0145v0150#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.14.5...v0.15.0\"\u003e[v0.15.0]\u003c/a\u003e":"","v0151httpsgithubcommlange-42archecomparev0150v0151#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.15.0...v0.15.1\"\u003e[v0.15.1]\u003c/a\u003e":"","v0152httpsgithubcommlange-42archecomparev0151v0152#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.15.1...v0.15.2\"\u003e[v0.15.2]\u003c/a\u003e":"","v0153httpsgithubcommlange-42archecomparev0152v0153#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.15.2...v0.15.3\"\u003e[v0.15.3]\u003c/a\u003e":"","v020httpsgithubcommlange-42archecomparev014v020#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.1.4...v0.2.0\"\u003e[v0.2.0]\u003c/a\u003e":"","v030httpsgithubcommlange-42archecomparev020v030#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.2.0...v0.3.0\"\u003e[v0.3.0]\u003c/a\u003e":"","v031httpsgithubcommlange-42archecomparev030v031#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.3.0...v0.3.1\"\u003e[v0.3.1]\u003c/a\u003e":"","v040httpsgithubcommlange-42archecomparev031v040#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.3.1...v0.4.0\"\u003e[v0.4.0]\u003c/a\u003e":"","v041httpsgithubcommlange-42archecomparev040v041#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.0...v0.4.1\"\u003e[v0.4.1]\u003c/a\u003e":"","v042httpsgithubcommlange-42archecomparev041v042#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.1...v0.4.2\"\u003e[v0.4.2]\u003c/a\u003e":"","v043httpsgithubcommlange-42archecomparev042v043#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.2...v0.4.3\"\u003e[v0.4.3]\u003c/a\u003e":"","v044httpsgithubcommlange-42archecomparev043v044#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.3...v0.4.4\"\u003e[v0.4.4]\u003c/a\u003e":"","v045httpsgithubcommlange-42archecomparev044v045#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.4...v0.4.5\"\u003e[v0.4.5]\u003c/a\u003e":"","v046httpsgithubcommlange-42archecomparev045v046#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.5...v0.4.6\"\u003e[v0.4.6]\u003c/a\u003e":"","v050httpsgithubcommlange-42archecomparev046v050#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.4.6...v0.5.0\"\u003e[v0.5.0]\u003c/a\u003e":"","v051httpsgithubcommlange-42archecomparev050v051#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.5.0...v0.5.1\"\u003e[v0.5.1]\u003c/a\u003e":"","v060httpsgithubcommlange-42archecomparev051v060#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.5.1...v0.6.0\"\u003e[v0.6.0]\u003c/a\u003e":"","v061httpsgithubcommlange-42archecomparev060v061#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.0...v0.6.1\"\u003e[v0.6.1]\u003c/a\u003e":"","v062httpsgithubcommlange-42archecomparev061v062#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.1...v0.6.2\"\u003e[v0.6.2]\u003c/a\u003e":"","v063httpsgithubcommlange-42archecomparev062v063#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.2...v0.6.3\"\u003e[v0.6.3]\u003c/a\u003e":"","v070httpsgithubcommlange-42archecomparev063v070#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.6.3...v0.7.0\"\u003e[v0.7.0]\u003c/a\u003e":"","v071httpsgithubcommlange-42archecomparev070v071#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.7.0...v0.7.1\"\u003e[v0.7.1]\u003c/a\u003e":"","v080httpsgithubcommlange-42archecomparev071v080#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.7.1...v0.8.0\"\u003e[v0.8.0]\u003c/a\u003e":"","v081httpsgithubcommlange-42archecomparev080v081#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.8.0...v0.8.1\"\u003e[v0.8.1]\u003c/a\u003e":"","v090httpsgithubcommlange-42archecomparev081v090#\u003ca href=\"https://github.com/mlange-42/arche/compare/v0.8.1...v0.9.0\"\u003e[v0.9.0]\u003c/a\u003e":""},"title":"_changelog"},"/arche/guide/":{"data":{"":"The following chapters are designed to be read sequentially in the presented order. If you are familiar with ECS and know what you are looking for, you may also just look it up or use the search.\nIf you are not familiar with the Entity Component System (ECS) concept, take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\nTip\nInline code referencing Arche’s API is linked to the API reference, like here: ecs.World."},"title":"User Guide"},"/arche/guide/apis/":{"data":{"":"Arche provides two different APIs:\nA generic API that is often the most convenient. But perhaps more importantly, it is type safe. It is the recommended way of usage for most users.\nAn ID-based API that is slightly faster than the generic one in some places. Further, it is more flexible and may be more appropriate for tasks like automated serialization.\nBoth APIs can be mixed as needed.\nTip\nIn this user guide, most code examples will be presented with two tabs, one for each API:\ngenericID-based 1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Velocity]() 4 5query := filter.Query(\u0026world) 6for query.Next() { 7\tpos, vel := query.Get() 8\tpos.X += vel.X 9\tpos.Y += vel.Y 10} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4velID := ecs.ComponentID[Velocity](\u0026world) 5filter := ecs.All(posID, velID) 6 7query := world.Query(\u0026filter) 8for query.Next() { 9\tpos := (*Position)(query.Get(posID)) 10\tvel := (*Velocity)(query.Get(posID)) 11\tpos.X += vel.X 12\tpos.Y += vel.Y 13} "},"title":"Generic \u0026 ID-based API"},"/arche/guide/batch-ops/":{"data":{"":"Compared to Queries and World Entity Access, creation and removal of entities or components are relatively costly operations. See the Benchmarks for some numbers.\nFor these operations, Arche provides batched versions. This allows to create or manipulate a large number of entities much faster than one by one. Most batch methods come in two flavors. A “normal” one, and one suffixed with Q that returns a query over the affected entities.","components#Components":"Components can be added, removed or exchanged in batch operations. For these operations, Arche provides ecs.World.Batch. Component batch operations take an ecs.Filter as an argument to determine the affected entities.\ngenericID-based 1world := ecs.NewWorld() 2 3// Create 100 entities with Position. 4builder := generic.NewMap1[Position](\u0026world) 5builder.NewBatch(100) 6 7// Create a generic map to perform the batch operation 8adder := generic.NewMap1[Heading](\u0026world) 9// Filter for entities with Position. 10filter := generic.NewFilter1[Position]() 11// Batch-add Heading to them, using the query method for initialization. 12query := adder.AddBatchQ(filter.Filter(\u0026world)) 13for query.Next() { 14\thead := query.Get() 15\thead.Angle = rand.Float64() * 360 16} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6// Create 100 entities with Position. 7world.Batch().New(100, posID) 8 9// Filter for entities with Position. 10filter := ecs.All(posID) 11// Batch-add Heading to them, using the query method for initialization. 12query := world.Batch().AddQ(filter, headID) 13for query.Next() { 14\thead := (*Heading)(query.Get(headID)) 15\thead.Angle = rand.Float64() * 360 16} Methods of interest for the ID-based API are:\necs.Batch.Add, ecs.Batch.AddQ ecs.Batch.Remove, ecs.Batch.RemoveQ ecs.Batch.Exchange, ecs.Batch.ExchangeQ Methods of interest for the generic API are:\ngeneric.Map2.AddBatch, generic.Map2.AddBatchQ generic.Map2.RemoveBatch, generic.Map2.RemoveBatchQ generic.Exchange.ExchangeBatch ","creating-entities#Creating entities":"Entity creation is probably the most common use case for batching. When the number of similar entities that are to be created are known, creation can be batched with ecs.Batch.New. In the generic API, MapX provide e.g. generic.Map2.NewBatch.\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5builder.NewBatch(100) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6world.Batch().New(100, posID, headID) However, this is only sometimes useful, as we can’t initialize component fields here.\nWith the query variant of the methods, suffixed with Q, we can fix this:\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5query := builder.NewBatchQ(100) 6for query.Next() { 7\tpos, head := query.Get() 8 9\tpos.X = rand.Float64() * 100 10\tpos.Y = rand.Float64() * 100 11\thead.Angle = rand.Float64() * 360 12} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6query := world.Batch().NewQ(100, posID, headID) 7for query.Next() { 8\tpos := (*Position)(query.Get(posID)) 9\thead := (*Heading)(query.Get(headID)) 10 11\tpos.X = rand.Float64() * 100 12\tpos.Y = rand.Float64() * 100 13\thead.Angle = rand.Float64() * 360 14} Here, we obtain a query over exactly the entities we just created, and can initialize their components.","relations#Relations":"Entity relations can be changed in batches, too. In the ID-based API, both ecs.Batch.SetRelation/ecs.Batch.SetRelationQ and ecs.Relations.SetBatch/ecs.Relations.SetBatchQ can be used. In the generic API, use generic.Map.SetRelation/generic.Map.SetRelationQ:\ngenericID-based 1world := ecs.NewWorld() 2 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5parent := world.NewEntity() 6 7// Create 100 entities with ChildOf relation. 8builder := generic.NewMap1[ChildOf](\u0026world) 9builder.NewBatch(100) 10 11// Create a generic map to perform the batch operation 12mapper := generic.NewMap[ChildOf](\u0026world) 13// Filter for entities with ChildOf. 14filter := ecs.All(childID) 15// Batch-set their relation target to parent. 16mapper.SetRelationBatch(filter, parent) 1world := ecs.NewWorld() 2 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5parent := world.NewEntity() 6 7// Create 100 entities with ChildOf relation. 8world.Batch().New(100, childID) 9 10// Filter for entities with ChildOf. 11filter := ecs.All(childID) 12// Batch-set their relation target to parent. 13world.Batch().SetRelation(filter, childID, parent) ","removing-entities#Removing entities":"Entities can be removed in batches using ecs.Batch.RemoveEntities:\ngenericID-based 1world := ecs.NewWorld() 2 3// Create 100 entities with Position. 4builder := generic.NewMap1[Position](\u0026world) 5builder.NewBatch(100) 6 7// Filter for entities with Position. 8filter := generic.NewFilter1[Position]() 9// Batch-remove matching entities. 10world.Batch().RemoveEntities(filter.Filter(\u0026world)) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4 5// Create 100 entities with Position. 6world.Batch().New(100, posID) 7 8// Filter for entities with Position. 9filter := ecs.All(posID) 10// Batch-remove matching entities. 11world.Batch().RemoveEntities(filter) "},"title":"Batch Operations"},"/arche/guide/entities/":{"data":{"":"Entities and components are the primary building blocks of the ECS concept.\nThis chapter explains their representation and manipulation in Arche.","add-and-remove-components#Add and remove components":"Components are added to and removed from entities through the world, with ecs.World.Add and ecs.World.Remove. With generics, use a generic.Map2 again:\ngenericID-based 1world := ecs.NewWorld() 2 3mapper := generic.NewMap2[Position, Heading](\u0026world) 4 5entity := world.NewEntity() 6 7mapper.Add(entity) 8mapper.Remove(entity) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity() 7 8world.Add(entity, posID, headID) 9world.Remove(entity, posID, headID) First, we add Position and Heading to the entity, then we remove both.\nImportant\nNote that generic types like MapX should be stored and re-used where possible, particularly over time steps.\nUsing the generic API, it is also possible to assign initialized components with generic.Map2.Assign, similar to Map2.NewWith:\n1world := ecs.NewWorld() 2 3mapper := generic.NewMap2[Position, Heading](\u0026world) 4 5entity := world.NewEntity() 6 7mapper.Assign( 8\tentity, 9\t\u0026Position{X: 1, Y: 2}, 10\t\u0026Heading{Angle: 180}, 11) ","components#Components":"With each entity, an arbitrary number of Components can be associated. Components are simple, user-defined Go structs (or other go types):\n1// Position component 2type Position struct { 3 X float64 4 Y float64 5} 6 7// Heading component 8type Heading struct { 9 Angle float64 10} Components are stored in the World and accessed through Queries or through the world itself (see World Entity Access).\nComponent IDs Each component type has a unique ID, which is used to access it in the ID-based API. Component IDs can be registered as well as obtained through ecs.ComponentID.\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6_, _ = posID, headID When a type is used as a component the first time, it is automatically registered. Thus, it is not necessary to register all required components during initialization.","create-entities#Create entities":"The most basic way to create an entity is ecs.World.NewEntity:\n1world := ecs.NewWorld() 2 3entity := world.NewEntity() 4_ = entity Here, we get an entity without any components. However, NewEntity takes an arbitrary number of components IDs for the components that should be associated with the entity:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6_ = world.NewEntity(posID) 7_ = world.NewEntity(posID, headID) We get an entity with Position, and another one with Position and Heading. The components of the entity are initialized with their zero values.\nImportant\nNote that entities should always be stored and passed around by value/copy, never via pointers!\nGeneric API Creating entities using the generic API requires a generic MapX, like generic.Map2:\n1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5_ = builder.New() We get an entity with Position and Heading, initialized to their zero values.\nAlternatively, entities can be created with initialized components through Map2.NewWith:\n1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5_ = builder.NewWith( 6\t\u0026Position{X: 1, Y: 2}, 7\t\u0026Heading{Angle: 180}, 8) We get an entity with Position and Heading, initialized according to values behind the passed pointers.\nTip\nThe 2 in Map2 stands for the number of components. In the generic API, there are also FilterX and QueryX. All these types are available for X in range 0 (or 1) to 12.\nBatch Creation For faster batch creation of many entities, see chapter Batch Operations.","entities#Entities":"An Entity (ecs.Entity) in Arche is merely an ID and contains no data itself.\nThe only method of an entity is ecs.Entity.IsZero. The only entity that can be directly created by the user is the zero entity, in two possible ways:\n1var zero1 ecs.Entity 2fmt.Println(zero1.IsZero()) // prints true 3 4zero2 := ecs.Entity{} 5fmt.Println(zero2.IsZero()) // prints true All other entities must be created through the ecs.World (see section Create entities below)","exchange-components#Exchange components":"Sometimes one or more components should be added to an entity, and others should be removed. This can be bundled into a single exchange operation for efficiency. This is done with ecs.World.Exchange, or using a generic.Exchange:\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[Position](\u0026world) 4entity := builder.New() 5 6exchange := generic.NewExchange(\u0026world). 7\tAdds(generic.T[Heading]()). // Component(s) to add. 8\tRemoves(generic.T[Position]()) // Component(s) to remove. 9 10exchange.Exchange(entity) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID) 7 8world.Exchange(entity, 9\t[]ecs.ID{headID}, // Component(s) to add. 10\t[]ecs.ID{posID}, // Component(s) to remove. 11) ","remove-entities#Remove entities":"Entities can be removed from the world with ecs.World.RemoveEntity:\n1world := ecs.NewWorld() 2 3entity := world.NewEntity() 4world.RemoveEntity(entity) After removal, the entity will be recycled. For that sake, each entity has a generation variable which allows to distinguish recycled entities. With ecs.World.Alive, it can be tested whether an entity is still alive:\n1world := ecs.NewWorld() 2 3entity := world.NewEntity() 4fmt.Println(world.Alive(entity)) // prints true 5 6world.RemoveEntity(entity) 7fmt.Println(world.Alive(entity)) // prints false "},"title":"Entities \u0026 Components"},"/arche/guide/events/":{"data":{"":"Arche features an event system that can be used to get notifications about world modifications, namely:\nEntity creation and removal Component addition, removal and exchange Changes of entity relation targets The event system is particularly useful for automating the management of supplementary data structures that store entities. It can be used to automatically insert entities into these structures on creation or component addition, and to remove them on entity or component removal.\nThe types of interest here are ecs.Listener and ecs.EntityEvent.","builtin-listener#Builtin listener":"An ecs.World can have at most one ecs.Listener. If required, this listener can be used to dispatch events to sub-listeners. Such a listener is provided by listener.Dispatch. In conjunction with listener.Callback, it is already possible to build a sophisticated event system.\nIn the following example, we compose a listener.Dispatch from two listener.Callback. The first one listens to all entity creation and entity removal events. The second one listens to events where a Position or a Heading is added to an entity.\n1world := ecs.NewWorld() 2posID := ecs.ComponentID[Position](\u0026world) 3headID := ecs.ComponentID[Heading](\u0026world) 4 5// Listener for all entity creation and entity removal events. 6entityListener := listener.NewCallback( 7\t// A function we want to call on notification. 8\tfunc(w *ecs.World, ee ecs.EntityEvent) { /* Do something here */ }, 9\t// Subscription to event types. 10\tevent.EntityCreated|event.EntityRemoved, 11) 12 13posOrHeadAddedListener := listener.NewCallback( 14\t// A function we want to call on notification. 15\tfunc(w *ecs.World, ee ecs.EntityEvent) { /* Do something here */ }, 16\t// Subscription to event types. 17\tevent.ComponentAdded, 18\t// Subscription is restricted to these component types. 19\tposID, headID, 20) 21 22// Create the dispatch listener from both sub-listeners. 23dispatch := listener.NewDispatch( 24\t\u0026entityListener, 25\t\u0026posOrHeadAddedListener, 26) 27// Set it as the world's listener. 28world.SetListener(\u0026dispatch) ","custom-listeners#Custom listeners":"Custom listeners can be created by implementing the interface ecs.Listener. Here is an example of a listener that listens to additions of a Position component:\n1package main 2 3import ( 4\t\"fmt\" 5 6\t\"github.com/mlange-42/arche/ecs\" 7\t\"github.com/mlange-42/arche/ecs/event\" 8) 9 10// PositionAddedListener listens to additions of a Position component. 11type PositionAddedListener struct { 12\tsubs event.Subscription 13\tcomps ecs.Mask 14} 15 16// NewPositionAddedListener creates a new PositionAddedListener. 17func NewPositionAddedListener(world *ecs.World) PositionAddedListener { 18\tposID := ecs.ComponentID[Position](world) 19\treturn PositionAddedListener{ 20\tsubs: event.ComponentAdded, 21\tcomps: ecs.All(posID), 22\t} 23} 24 25// Notify the listener about a subscribed event. 26func (l *PositionAddedListener) Notify(world *ecs.World, evt ecs.EntityEvent) { 27\tfmt.Println(\"Position component added to entity \", evt.Entity) 28} 29 30// Subscriptions to one or more event types. 31func (l *PositionAddedListener) Subscriptions() event.Subscription { 32\treturn l.subs 33} 34 35// Components the listener subscribes to. Listening to all components indicated by nil. 36func (l *PositionAddedListener) Components() *ecs.Mask { 37\treturn \u0026l.comps 38} ","entityevent#EntityEvent":"In Listener.Notify, as well as in the callback for listener.Callback, we get an ecs.EntityEvent as argument. It provides all sorts of information about the event, like the affected ecs.Entity, event types covered, components added and removed, and more. See the API docs of ecs.EntityEvent for details.","subscriptions#Subscriptions":"A listener must subscribe to certain event types. These are constants of type ecs.event.Subscription:\n1_ = event.EntityCreated 2_ = event.EntityRemoved 3_ = event.ComponentAdded 4_ = event.ComponentRemoved 5_ = event.RelationChanged 6_ = event.TargetChanged Multiple event types can be combined using bit-wise OR (|):\n1subs := event.EntityCreated | event.EntityRemoved 2_ = subs Some combinations of event types are already defined as ecs.event.Subscription. E.g., to subscribe to all event types, use event.All.\nBesides subscribing to event types, subscriptions can be restricted to certain component types that must be affected by the event. Component type subscriptions are realized using the same ecs.Mask mechanics that filters use. Create masks with ecs.All:\n1world := ecs.NewWorld() 2posID := ecs.ComponentID[Position](\u0026world) 3headID := ecs.ComponentID[Heading](\u0026world) 4 5compSubs := ecs.All(posID, headID) 6_ = compSubs A listener with this component subscription would be notified on changes that are related to the Position or to the Heading component."},"title":"Event System"},"/arche/guide/filters/":{"data":{"":"Filters provide the logic for filtering entities in Queries.\nDue to the archetype-based architecture of Arche :wink:, filters are very efficient. Instead of against every single entity, they are only matched against archetypes.\nThe following sections present the filtering options available in Arche.\nImportant\nFilters should be stored and re-used where possible, particularly over time steps. Contrary, Queries are for one-time utilization and must be created from a filter before every iteration loop.","core-filters#Core filters":"Mask The most common filter is a simple ecs.Mask, which is usually generated with the function ecs.All:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6mask := ecs.All(posID, headID) 7 8query := world.Query(\u0026mask) 9query.Close() Simple ecs.Mask filters match all entities that have at least all the specified components. The generic equivalent is a simple FilterX, e.g. generic.Filter2:\n1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Heading]() 4query := filter.Query(\u0026world) 5query.Close() In both examples, we filter for all entities that have Position and Heading, and anything else that we are not interested in.\nWithout Particular components can be excluded with ecs.Mask.Without and generic.Filter2.Without:\ngenericID-based 1filter := generic.NewFilter1[Position](). 2\tWithout(generic.T[Heading]()) 3 4_ = filter 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6mask := ecs.All(posID).Without(headID) 7_ = mask Here, we filter for all entities that have a Position, but no Heading. Other components are allowed on the entities.\nExclusive With ecs.Mask.Exclusive and generic.Filter2.Exclusive, we can exclude all components that are not in the filter:\ngenericID-based 1filter := generic.NewFilter2[Position, Heading](). 2\tExclusive() 3_ = filter 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6mask := ecs.All(posID, headID).Exclusive() 7_ = mask I.e., we get only entities with exactly the given components, and no more.\nWith \u0026 Optional With the ID-based API, queries allow access to any component, irrespective of whether it was included in the query. Generic queries, however, can access only the queried components. Therefore, generic filters can have optional components through generic.Filter2.Optional:\n1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Heading](). 4\tOptional(generic.T[Heading]()) 5 6query := filter.Query(\u0026world) 7for query.Next() { 8\t_, head := query.Get() 9\tif head == nil { 10\t// Optional component Heading not present 11\tfmt.Println(\"Heading not present in entity \", query.Entity()) 12\t} 13} Note that the now optional Heading must be specified also in the original filter. In case an optional component is not present, Get returns nil for it.\nFurther, generic filters have generic.Filter2.With. This requires the respective component(s) to be present, but they are not obtained through Get:\n1world := ecs.NewWorld() 2 3filter := generic.NewFilter1[Position](). 4\tWith(generic.T[Heading]()) 5 6query := filter.Query(\u0026world) 7for query.Next() { 8\tpos := query.Get() 9\t_ = pos 10} Relation filters Filters for Entity Relations are covered in the respective chapter.","filter-caching#Filter caching":"Normally, when iterating a Query, the underlying filter is evaluated on each archetype. With a high number of archetypes in the world, this can slow down query iteration and other query functions.\nTo prevent this slowdown, filters can be registered to the ecs.World.Cache via ecs.Cache.Register. For generic filters, there is generic.Filter2.Register:\ngenericID-based 1world := ecs.NewWorld() 2 3filter := generic.NewFilter1[Position]() 4filter.Register(\u0026world) 5 6query := filter.Query(\u0026world) 7query.Close() 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4 5mask := ecs.All(posID) 6filter := world.Cache().Register(mask) 7 8// Use the registered filter in queries! 9query := world.Query(\u0026filter) 10query.Close() For registered filters, the list of matching archetypes is cached internally. Thus, no filter evaluations are required during iteration. Instead, filters are only evaluated when a new archetype is created.\nWhen a registered filter is not required anymore, it can be unregistered with ecs.Cache.Unregister or generic.Filter2.Unregister, respectively. However, this is rarely required as (registered) filters are usually used over an entire simulation run.","logic-filters#Logic filters":"Package filter provides logic combinations of filters. Logic filters can only be used with the ID-based API. Here are some examples:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4velID := ecs.ComponentID[Velocity](\u0026world) 5headID := ecs.ComponentID[Heading](\u0026world) 6 7// Either Position and Velocity, or Position and Heading. 8_ = filter.OR{ 9\tL: ecs.All(posID, velID), 10\tR: ecs.All(posID, headID), 11} 12 13// Same as above, expressed with a different logic. 14_ = filter.AND{ 15\tL: ecs.All(posID), 16\tR: filter.Any(velID, headID), 17} 18 19// Missing any of Position or Velocity. 20_ = filter.AnyNot(posID, velID) "},"title":"Filters"},"/arche/guide/performance/":{"data":{"":"","filter-caching#Filter caching":"When working with many archetypes, queries can be sped up by caching the underlying filter. This way, the filter is not checked against archetypes during query iteration. Instead, the archetypes relevant for the filter are cached, and checks are only required when new archetypes are created.\nFor details, see the section on caching in chapter Filters.","optimized-for-iteration#Optimized for Iteration":"","queries--components#Queries \u0026amp; Components":"Arche is highly optimized and can compete with mature ECS implementations in terms of performance. It will probably not get into your way in this regard. Experience shows that in simulation built with Arche, ECS code like queries, entity creation etc. takes between 5% and 15% of the total CPU time. Keep in mind that this is not “on top” of the simulation, but replaces the overhead any other implementation for storing and iterating entities would have. Due to its cache-friendliness, archetype-based ECS can outperform e.g. an Array of Structs implementation, particularly for simulations with many entities and/or many variables per entity.\nNevertheless, each ECS has its strengths and weaknesses. This chapter provides tips on what you should pay attention to in order to get the most out of Arche.\nOptimized for Iteration Being an archetype-based ECS, Arche is optimized for queries and iteration. Adding and removing components is comparatively costly with this architecture, because components must be moved around between archetypes. The runtime difference between accessing a component and adding/removing a component is at least one order of magnitude. For some numbers for comparison, see the Benchmarks.\nQueries \u0026 Components The largest potential for optimizing queries is the clever design of components. The aim should be that queries access only data that is actually required, while at the same time reducing the amount of accessed components. Accessing fewer data means fewer cache misses, while accessing fewer components avoids lookups. To access only data that it actually required primarily means that the accessed components should contain only data that is used by the query.\nA component should only contain closely related data that is mostly or always accessed together. A Position component with X and Y is a good example. Vice versa, closely related data should be in the same component. What should be avoided are all-in-one components that mimic OOP classes to represent entities. A good (or rather, bad) example is a Tree component with X, Y, Biomass, Height, StemDiameter and LeaveAreaIndex (or more).\nFor fast memory access, the use of slices in components should be avoided. Use fixed-size arrays where possible.","world-access#World access":"World access to components with ecs.World.Get is per se slower than access through a query, as there is one more indirection and the alive status of the entity is checked for safety. Queries should be preferred over world access where possible.\nFurther, world access can’t benefit from the cache-friendly linearity of query iterations. This becomes more severe when the length of “jumps” between entities increases. Thus, is it more efficient to randomly access among e.g. 1000 entities compared to 100k entities.\nAs an example, say we have 1000 parent entities, 100k child entities, and don’t use Entity Relations. Here, it would be better to use a query over the children and access the parent of each child by world access. We jump around between 1000 entities. Alternatively, we could query the parents and access the children of each parent by world access. The number of accesses through the world would be the same, but we would jump between 100k entities, which would be slower.\nSee also the benchmarks for Entity Relations.","world-operations#World operations":"As explained above, operations like adding and removing components or creating entities are relatively costly in an archetype-based ECS. However, Arche provides some optimizations here, and following a few principles can help keeping the performance cost at a minimum.\nAvoiding Different components are a great way to represent different states of otherwise similar entities. For example, it is completely valid to build a finite state machine to model behavior, using components to represent states. However, each state transition results in moving an entity and its components between archetypes. Thus, when transitions occur frequently (say faster than every 20 ticks), different components are not the most efficient way to represent states. Alternatively, states could be represented by a variable in a single component, avoiding the overhead of moving entities between archetypes, at the cost of overhead in the queries.\nIt is a matter of weighting, and potentially benchmarking, to decide on what is represented by components in a query-able way, and what is left to be managed inside query loops.\nMultiple at once, Exchange As explained above, moving entities between archetypes is relatively costly. It is necessary when adding or removing components, but multiple components can be added or removed with a single transition between archetypes.\nFor that sake, methods like ecs.World.Add and ecs.World.Remove take an arbitrary number of component IDs as arguments. The generic API provides all types and functions for up to 12 components. Add or remove components together instead of one after another!\nFurther, ecs.World.Exchange and generic.Exchange allow to add some components and remove others at the same time. This also requires only a single transition between archetypes.\nBatching Arche provides batched variants of all operations like creating entities, adding and removing components, etc. Batching can speed up operations by up to an order of magnitude. It allows for bulk allocation of component memory and entities, and cuts off the overhead that is otherwise required for each entity, repeatedly. Entity creation is the most common use case for batching. For details, see the chapter on Batch Operations.\nSee also the Benchmarks for batched vs. un-batched operations."},"title":"Performance Tips"},"/arche/guide/queries/":{"data":{"":"","other-functionality#Other functionality":"Besides ecs.Query.Next, ecs.Query.Get and ecs.Query.Entity that we used above, queries have a few more useful methods.\nQuery.Count ecs.Query.Count allows for counting the entities in a query, very fast:\n1world := ecs.NewWorld() 2 3filter := ecs.All() 4query := world.Query(\u0026filter) 5 6cnt := query.Count() 7fmt.Println(cnt) 8 9query.Close() Note that we need to call ecs.Query.Close here, as the query was not (fully) iterated! After ecs.Query.Count, the query could also be iterated as usual.\nQuery.EntityAt With ecs.Query.EntityAt, queries also support access by index. This is particularly useful to select random entities from a query, like in this example:\n1world := ecs.NewWorld() 2 3// Create some entities. 4for i := 0; i \u003c 100; i++ { 5\tworld.NewEntity() 6} 7 8// Create a filter 9filter := ecs.All() 10 11// Query and count entities. 12query := world.Query(\u0026filter) 13cnt := query.Count() 14 15// Draw random entities. 16for i := 0; i \u003c 10; i++ { 17\tentity := query.EntityAt(rand.Intn(cnt)) 18\tfmt.Println(entity) 19} 20 21query.Close() Note that we need to close the query manually, again! To access components of the retrieved entities, see chapter World Entity Access.\nNote that ecs.Query.EntityAt may be slow when working with a large number of archetypes. Often, it is useful to register the underlying filter for speedup. See chapter Filter, section Filter caching for details. See the query benchmarks for some numbers on performance.","query-creation--iteration#Query creation \u0026amp; iteration":"Queries (ecs.Query) are the heart of Arche’s query engine. They allow for very fast retrieval and iteration of entities with certain components.\nImportant\nQueries are for one-time utilization. A query can be iterated through only once, and a new one must be created before every loop. Contrary, the underlying Filters should be stored and re-used.\nQuery creation \u0026 iteration Queries are created through the ecs.World using a Filter (interface ecs.Filter). The most basic type of filter is ecs.Mask. For more advanced filters, see chapter Filters.\nHere, we create a filter that gives us all entities with all the given components, and potentially further components. Then, we create an ecs.Query (or generic QueryX, e.g. generic.Query2) and iterate it.\ngenericID-based 1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Velocity]() 4query := filter.Query(\u0026world) 5for query.Next() { 6\tpos, vel := query.Get() 7\tpos.X += vel.X 8\tpos.Y += vel.Y 9} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4velID := ecs.ComponentID[Velocity](\u0026world) 5 6filter := ecs.All(posID, velID) 7query := world.Query(\u0026filter) 8for query.Next() { 9\tpos := (*Position)(query.Get(posID)) 10\tvel := (*Velocity)(query.Get(velID)) 11\tpos.X += vel.X 12\tpos.Y += vel.Y 13} Where ecs.Query.Get (resp. generic.Query2.Get) return components of the entity at the current query iterator position.\nImportant\nNote that the component pointers obtained from queries should never be stored persistently, and should only be used inside the query loop.\nComparing the two versions of the code above, one can clearly observe the advantages of the generic API over the ID-based API (see chapter on APIs). Firstly, the generic code is shorter and more readable. But even more importantly, it much safer. A little mistake in line 9 or 10 of the ID-based version could result in silently casting a component to the wrong type, which would lead to bugs that are hard to track down.\nTip\nIf you get error messages like “index out of range [-1]” or “invalid memory address or nil pointer dereference” from queries, you are probably using them in the wrong way. Try running with build tag debug for more helpful error messages:\ngo run -tags debug . ","world-lock#World lock":"When a query gets created, the ecs.World gets locked for modifications. When locked, no entities can be created or removed, and no components can be added to or removed from entities.\nWhen a query is fully iterated, the world gets unlocked again. When a query is not fully iterated for some reason (see next section for examples), it must be closed with ecs.Query.Close.\nDue to the world lock, denied operations like entity creation or removal must be deferred:\n1world := ecs.NewWorld() 2 3// Create some entities. 4for i := 0; i \u003c 100; i++ { 5\tworld.NewEntity() 6} 7 8// A slice that we (re)-use to defer entity removal. 9var toRemove []ecs.Entity 10 11// Create a filter 12filter := ecs.All() 13 14// A time loop. 15for time := 0; time \u003c 100; time++ { 16\t// Query... the world gets locked. 17\tquery := world.Query(\u0026filter) 18\t// Iterate, and collect entities to remove. 19\tfor query.Next() { 20\tif rand.Float64() \u003c 0.1 { 21\ttoRemove = append(toRemove, query.Entity()) 22\t} 23\t} 24\t// The world is unlocked again. 25\t// Actually remove the collected entities. 26\tfor _, e := range toRemove { 27\tworld.RemoveEntity(e) 28\t} 29\t// Empty the slice, so we can reuse it in the next time step. 30\ttoRemove = toRemove[:0] 31} Where ecs.Query.Entity returns the entity at the current query iterator position."},"title":"Queries"},"/arche/guide/relations/":{"data":{"":"In a basic ECS, relations between entities, like hierarchies, can be represented by storing entities in components. E.g., we could have a child component like this:\n1type ChildOf struct { 2 Parent ecs.Entity 3} Or, alternatively, a parent component with many children:\n1type Parent struct { 2 Children []ecs.Entity 3} In conjunction with World Entity Access, this is often sufficient. However, we are not able to leverage the power of queries to e.g. get all children of a particular parent.\nTo make entity relations even more useful and efficient, Arche supports them as first class feature. Relations are added to and removed from entities just like components, and hence can be queried like components, with the usual efficiency. This is achieved by creating separate archetypes for relations with different target entities.","benchmarks#Benchmarks":"The figure below compares the iteration time per entity for different ways of representing entity relations. The task is to sum up a value over the children of each parent.\nThe following ways to represent entity relations are shown in the figure:\nParentList (purple): Children form an implicit linked list. The parent references the first child. Query over parents, inner loop implicit linked list of children, using world access for next child and value component. ParentSlice (red): The parent holds a slice of all its children. Query over parents, inner loop over slice of children using world access for value component. Child (green): Each child references its parent. Query over all child entities and retrieval of the parent sum component using world access. Default (blue): Using Arche’s relations feature without filter caching. Outer query over parents, inner loop over children using relation queries. Cached (black): Using Arche’s relations feature with filter caching. Same as above, using an additional component per parent to store cached filters. The first three representations are possible in any ECS, while the last two use Arche’s entity relations feature.\nIteration time per entity for different ways of representing entity relations. Color: ways to represent entity relations; Line style: total number of child entities; Markers: number of children per parent entity\nThe benchmarks show that Arche’s relations feature outperforms the other representations, except when there are very few children per parent. Only when there is a huge number of parents and significantly fewer than 100 children per parent, the Child representation should perform better.\nThe benchmark code can be found in the GitHub repository.","creating-relations#Creating relations":"On new entities When creating entities, we can use an ecs.Builder to set a relation target. In the generic API, we use a MapX (e.g. generic.Map2).\ngenericID-based 1world := ecs.NewWorld() 2 3// The second argument specifies the relation component. 4builder := generic.NewMap2[Position, ChildOf](\u0026world, generic.T[ChildOf]()) 5 6_ = builder.New() // An entity with a zero target. 7 8parent := world.NewEntity() 9_ = builder.New(parent) // An entity with parent as target. 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4childID := ecs.ComponentID[ChildOf](\u0026world) 5 6// We set the relation component with WithRelation. 7builder := ecs.NewBuilder(\u0026world, posID, childID).WithRelation(childID) 8 9_ = builder.New() // An entity with a zero target. 10 11parent := world.NewEntity() 12_ = builder.New(parent) // An entity with parent as target. When adding components A relation target can also be given when adding a relation component. With the ID-based API, we use the helper ecs.World.Relations for this, like for most operations on entity relations. In the generic API, we use a MapX (e.g. generic.Map2) again.\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[Position](\u0026world) 4adder := generic.NewMap1[ChildOf](\u0026world, generic.T[ChildOf]()) 5 6parent := world.NewEntity() 7child := builder.New() 8 9adder.Add(child, parent) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4childID := ecs.ComponentID[ChildOf](\u0026world) 5 6parent := world.NewEntity() 7child := world.NewEntity(posID) 8 9world.Relations().Exchange( 10\tchild, // The entity to modify 11\t[]ecs.ID{childID}, // Component(s) to add 12\tnil, // Component(s) to remove 13\tchildID, // The relation component of the added components 14\tparent, // The target entity 15) Alternatively, we can use a generic.Exchange:\n1world := ecs.NewWorld() 2 3builder := generic.NewMap1[Position](\u0026world) 4adder := generic.NewExchange(\u0026world). 5\tAdds(generic.T[ChildOf]()). // Component(s) to add 6\tWithRelation(generic.T[ChildOf]()) // The relation component of the added components 7 8parent := world.NewEntity() 9child := builder.New() 10 11adder.Add(child, parent) ","limitations#Limitations":"Entity relations in Arche are inspired by Flecs. However, the implementation in Arche is currently limited in that it only supports a single relation per entity, and no chained (or nested) relation queries.","longer-example#Longer example":"To conclude this chapter, here is a longer example that uses Arche’ entity relations feature to represent tree species in a forest model.\n1package main 2 3import ( 4\t\"math/rand\" 5 6\t\"github.com/mlange-42/arche/ecs\" 7\t\"github.com/mlange-42/arche/generic\" 8) 9 10// SpeciesParams component for species (relation targets). 11type SpeciesParams struct { 12\tGrowthRate float64 13} 14 15// Species relation component for tree individuals. 16type Species struct { 17\tecs.Relation 18} 19 20// Biomass component for tree individuals. 21type Biomass struct { 22\tBM float64 23} 24 25func main() { 26\tworld := ecs.NewWorld() 27 28\tspeciesBuilder := generic.NewMap1[SpeciesParams](\u0026world) 29\ttreeBuilder := generic.NewMap2[Biomass, Species](\u0026world, generic.T[Species]()) 30 31\t// Create 10 species. 32\tfor s := 0; s \u003c 10; s++ { 33\tspecies := speciesBuilder.NewWith( 34\t\u0026SpeciesParams{GrowthRate: rand.Float64()}, 35\t) 36 37\t// Create 100 trees per species. Biomass is zero. 38\tfor t := 0; t \u003c 100; t++ { 39\ttreeBuilder.New(species) 40\t} 41\t} 42 43\tspeciesFilter := generic.NewFilter1[SpeciesParams]() 44\ttreeFilter := generic.NewFilter1[Biomass](). // We want to access biomass. 45\tWith(generic.T[Species]()). // We want this, but will not access it 46\tWithRelation(generic.T[Species]()) // Finally, the relation. 47 48\t// Time loop. 49\tfor tick := 0; tick \u003c 100; tick++ { 50\t// Query and iterate species. 51\tspeciesQuery := speciesFilter.Query(\u0026world) 52\tfor speciesQuery.Next() { 53\t// Get species params and entity. 54\tparams := speciesQuery.Get() 55\tspecies := speciesQuery.Entity() 56 57\t// Query and iterate trees for the current species. 58\ttreeQuery := treeFilter.Query(\u0026world, species) 59\tfor treeQuery.Next() { 60\tbm := treeQuery.Get() 61\t// Increase biomass by the species' growth rate. 62\tbm.BM += params.GrowthRate 63\t} 64\t} 65\t} 66 67\t_ = world 68} ","querying-relations#Querying relations":"And now for the best: querying for entities that have a certain relation and target.\nIn the ID-based API, relation targets can be queries with ecs.RelationFilter. In the generic API, it is supported by all FilterX via e.g. generic.Filter2.WithRelation.\ngenericID-based 1world := ecs.NewWorld() 2 3// Two parent entities. 4parent1 := world.NewEntity() 5parent2 := world.NewEntity() 6 7// A builder with a relation 8builder := generic.NewMap2[Position, ChildOf](\u0026world, generic.T[ChildOf]()) 9 10// Create 10 entities for each parent. 11for i := 0; i \u003c 10; i++ { 12\tbuilder.New(parent1) 13\tbuilder.New(parent2) 14} 15 16// A filter for all entities with Position, 17// and a ChildOf relation. 18filter := generic.NewFilter2[Position, ChildOf](). 19\tWithRelation(generic.T[ChildOf]()) 20 21// We specify the target when querying. 22// Alternatively, a fixed target can be specified in WithRelation above. 23query := filter.Query(\u0026world, parent1) 24fmt.Println(query.Count()) // Prints 10 25 26query.Close() 1world := ecs.NewWorld() 2posID := ecs.ComponentID[Position](\u0026world) 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5// Two parent entities. 6parent1 := world.NewEntity() 7parent2 := world.NewEntity() 8 9// A builder with a relation 10builder := ecs.NewBuilder(\u0026world, posID, childID). 11\tWithRelation(childID) 12 13// Create 10 entities for each parent. 14for i := 0; i \u003c 10; i++ { 15\tbuilder.New(parent1) 16\tbuilder.New(parent2) 17} 18 19// A filter for all entities with Position, 20// and ChildOf with target parent1. 21filter := ecs.NewRelationFilter(ecs.All(posID, childID), parent1) 22 23query := world.Query(\u0026filter) 24fmt.Println(query.Count()) // Prints 10 25 26query.Close() ","relation-components#Relation components":"To use entity relations, create components that have embedded an ecs.Relation as their first member:\n1type ChildOf struct { 2 ecs.Relation 3} That’s all to make a component be treated as an entity relation by Arche. Thus, we have created a relation type. When added to an entity, a target entity for the relation can be defined.\nTip\nNote that each entity can only have one relation component. See section Limitations.","set-and-get-relations#Set and get relations":"We can also change the target of an already assigned relation component. This is done via ecs.Relations.Set or generic.Map.SetRelation:\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[ChildOf](\u0026world) 4mapper := generic.NewMap[ChildOf](\u0026world) 5 6parent := world.NewEntity() 7child := builder.New() 8 9mapper.SetRelation(child, parent) 1world := ecs.NewWorld() 2 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5parent := world.NewEntity() 6child := world.NewEntity(childID) 7 8world.Relations().Set(child, childID, parent) Similarly, relation targets can be obtained with ecs.Relations.Get or generic.Map.GetRelation:\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[ChildOf](\u0026world) 4mapper := generic.NewMap[ChildOf](\u0026world) 5 6child := builder.New() 7 8_ = mapper.GetRelation(child) 1world := ecs.NewWorld() 2childID := ecs.ComponentID[ChildOf](\u0026world) 3 4child := world.NewEntity(childID) 5 6_ = world.Relations().Get(child, childID) ","when-to-use-and-when-not#When to use, and when not":"When using Arche’s entity relations, an archetype is created for each target entity of a relation. Thus, entity relations are not efficient if the number of target entities is high (tens of thousands), while only a low number of entities has a relation to each particular target (less than a few dozens). Particularly in the extreme case of 1:1 relations, storing entities in components as explained in the introduction of this chapter is more efficient.\nHowever, with a moderate number of relation targets, particularly with many entities per target, entity relations are very efficient. See section Benchmarks below, for a comparison of different ways to represent entity relations.\nBeyond use cases where the relation target is a “physical” entity that appears in a simulation or game, targets can also be more abstract, like categories. Examples:\nDifferent tree species in a forest model Behavioral states in a finite state machine The opposing factions in a strategy game Render layers in a game or other graphical application This concept is particularly useful for things that would best be expressed by components, but the possible components (or categories) are only known at runtime. Thus, it is not possible to create ordinary components for them. However, these categories can be represented by entities, which are used as relation targets.\nSee the last section of this chapter (Longer example) for an implementation of the tree species example above."},"title":"Entity Relations"},"/arche/guide/resources/":{"data":{"":"So far, we stored all data in components, associated to entities. However, sometimes this is not optimal. This particularly applies to non-ECS data structures, and “things” that appear only once in a model or game.\nFor these cases, Arche provides so-called ecs.Resources. A resource can be thought of as a component that only appears once, globally, in an ecs.World.","accessing-resources#Accessing resources":"Access to resources is obtained via ecs.World.Resources in the ID-based API, and via generic.Resource in the generic API:\ngenericID-based 1world := ecs.NewWorld() 2 3// Create the resource, and add a pointer to it to the world. 4grid := NewGrid(30, 20) 5ecs.AddResource(\u0026world, \u0026grid) 6 7// Then, somewhere else in the code... 8gridRes := generic.NewResource[Grid](\u0026world) 9grid2 := gridRes.Get() 10 11_ = grid2.Data[1][2] 1world := ecs.NewWorld() 2 3// Create the resource, and add a pointer to it to the world. 4grid := NewGrid(30, 20) 5ecs.AddResource(\u0026world, \u0026grid) 6 7// Then, somewhere else in the code... 8gridID := ecs.ResourceID[Grid](\u0026world) 9grid2 := world.Resources().Get(gridID).(*Grid) 10 11_ = grid2.Data[1][2] Note that in the ID-based example, we need to cast the pointer retrieved from ecs.Resources.Get to *Grid, similar to the cast in ID-based component access. However, the syntax is a bit different here as we cast an interface{}, rather than an unsafe.Pointer for components.\nAs with components, the generic API is the recommended way for normal usage.","adding-resources#Adding resources":"The most simple way to add a resource to the world is the function ecs.AddResource:\n1world := ecs.NewWorld() 2 3// Create the resource, and add a pointer to it to the world. 4grid := NewGrid(30, 20) 5ecs.AddResource(\u0026world, \u0026grid) An ID is automatically assigned to type Grid here, if it was not registered before with ecs.ResourceID.\necs.AddResource, however, is not particularly efficient. If a resource needs to be added (and removed) repeatedly, use ecs.World.Resources:\n1world := ecs.NewWorld() 2gridID := ecs.ResourceID[Grid](\u0026world) 3 4// Create the resource, and add a pointer to it to the world. 5grid := NewGrid(30, 20) 6world.Resources().Add(gridID, \u0026grid) ","resource-ids#Resource IDs":"Also analogous to components, resources are identified by a unique ID that can be obtained or registered using ecs.ResourceID:\n1world := ecs.NewWorld() 2 3gridID := ecs.ResourceID[Grid](\u0026world) 4_ = gridID As with components, a resource is registered and assigned an ID on first use automatically.","resource-types#Resource types":"Just like with components, any Go struct (or other Go type) can be a resource. An example:\n1type Grid struct { 2 Data [][]ecs.Entity 3 Width int 4 Height int 5} "},"title":"ECS Resources"},"/arche/guide/stats/":{"data":{"":"Arche only exposes the API required for actual use. Therefore, internals like the number of archetypes, memory used to store components etc. are not directly accessible.\nHowever, it might sometimes be useful to have access to such metrics, for example in order to judge effects of different ways of implementing something. Otherwise, users would have to rely on logic reasoning and sufficient understanding of Arche to derive these numbers.\nFor that sake, Arche provides statistics about its internals, prepared in a compact and digestible form.","accessing-statistics#Accessing statistics":"All internal statistics can be accessed via ecs.World.Stats, which returns a *stats.World. This, in turn, contains the other stats types described below. All these types have a method String() to bring them into a compact, human-readable form.\n1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4builder.NewBatch(100) 5 6stats := world.Stats() 7fmt.Println(stats) Which prints:\n1World -- Components: 2, Nodes: 3, Filters: 0, Memory: 7.0 kB, Locked: false 2 Components: Position, Heading 3Entities -- Used: 100, Recycled: 0, Total: 100, Capacity: 128 4Node -- Components: 0, Entities: 0, Capacity: 1, Memory: 0.0 kB, Per entity: 0 B 5 Components: 6Node -- Components: 2, Entities: 100, Capacity: 128, Memory: 4.0 kB, Per entity: 24 B 7 Components: Position, Heading ","archetype-stats#Archetype stats":"stats.Archetype contains size, capacity and memory information for an archetype.","entity-stats#Entity stats":"stats.Entities contains information about the entity pool, live capacity, alive entities and available entities for recycling.","node-stats#Node stats":"stats.Node provides information about an archetype node, like its components, memory in total and per entity, and more state information.\nFurther, it contains a stats.Archetype for each archetype.","world-stats#World stats":"stats.World provides world information like a list of all component types and the total memory reserved for entities and components. Further, it contains stats.Entities and a stats.Node for each active archetype node."},"title":"World Statistics"},"/arche/guide/tools/":{"data":{"":"A number of tools has been created for Arche.\nIf you wrote a tool and want it to be included here, please open an issue on GitHub.\narche-serde provides JSON serialization and deserialization for Arche’s World.\narche-model provides a wrapper around Arche, and some common systems and resources. its purpose is to get started with prototyping and developing simulation models immediately, focussing on the model logic.\narche-pixel provides OpenGL graphics and live plots for Arche using the Pixel game engine.\narche-demo provides examples of Arche models, which can be viewed in a live demo."},"title":"Tools"},"/arche/guide/world-access/":{"data":{"":"So far, we only used ecs.Query to access components. Component access in queries is highly efficient, but it does not provide access to the components of a specific entity. This is possible through ecs.World methods, or using a generic MapX (like generic.Map2) or generic.Map.","getting-components#Getting components":"For a given entity, components can be accessed using ecs.World.Get or generic.Map2.Get, respectively:\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4entity := builder.New() 5 6pos, head := builder.Get(entity) 7 8_, _ = pos, head 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID, headID) 7 8pos := (*Position)(world.Get(entity, posID)) 9head := (*Heading)(world.Get(entity, headID)) 10 11_, _ = pos, head Similarly, it is also possible to check if an entity has a given component with ecs.World.Has or generic.Map.Has, respectively:\ngenericID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4entity := builder.New() 5 6mapper := generic.NewMap[Position](\u0026world) 7 8hasPos := mapper.Has(entity) 9_ = hasPos 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID, headID) 7 8hasPos := world.Has(entity, posID) 9_ = hasPos Note that we have to use generic.Map here, which is similar to generic.Map1 for a single component, but offers more functionality.\nImportant\nNote that the component pointers obtained here should never be stored persistently.","unchecked-access#Unchecked access":"The Get and Has methods shown above all have a companion GetUnchecked and HasUnchecked, which is faster, but should be used with care. Particularly, they do not check whether the entity is still alive. Like Get, they panic when called on a removed entity. However, for a removed and subsequently recycled entity, they lead to undefined behavior.\nIt is safe to use methods like ecs.World.GetUnchecked after a usual Get was used on the same entity:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID, headID) 7 8pos := (*Position)(world.Get(entity, posID)) 9head := (*Heading)(world.GetUnchecked(entity, headID)) 10 11_, _ = pos, head Note that, following this use case, generic MapX internally use ecs.World.GetUnchecked for all but the first component."},"title":"World Entity Access"},"/arche/guide/world/":{"data":{"":"The World (ecs.World) is the central data storage in Arche. It manages and stores entities (ecs.Entity), their components, as well as Resources. For the internal structure of the world, see chapter Architecture.\nHere, we only deal with world creation. Most world functionality is covered in chapters Entities \u0026 Components and World Entity Access.","reset-the-world#Reset the world":"For systematic simulations, it is possible to reset a populated world for reuse:\n1world := ecs.NewWorld() 2// ... do something with the world 3 4world.Reset() 5// ... start over again ","world-creation#World creation":"To create a world with default settings, use ecs.NewWorld:\n1world := ecs.NewWorld() 2_ = world A world can also be configured with an initial capacity:\n1world := ecs.NewWorld(1024) 2_ = world The initial capacity is used to initialize archetypes, the entity list, etc.\nFor archetypes with an Entity Relation, a separate initial capacity can be specified:\n1world := ecs.NewWorld(1028, 128) 2_ = world "},"title":"The World"},"/arche/made_with/":{"data":{"":"If you made something using Arche and would like to see it here, feel free to open an issue or start a discussion in the GitHub repository.\nTiny WorldA tiny, slow-paced world and colony building game. Arche DemoDemo models and visualizations for Arche. BeecsThe BEEHAVE honeybee model, using Arche. "},"title":"Made with Arche"},"/arche/quickstart/":{"data":{"":"","installation#Installation":"","usage-example#Usage example":"","whats-next#What\u0026rsquo;s next?":"This page shows how to install Arche, and gives a minimal usage example.\nFinally, it points into possible directions to continue.\nInstallation To use Arche in a Go project, run:\n1go get github.com/mlange-42/arche Usage example Here is the classical Position/Velocity example that every ECS shows in the docs. It uses the type-safe generic API.\n1package main 2 3import ( 4\t\"math/rand\" 5 6\t\"github.com/mlange-42/arche/ecs\" 7\t\"github.com/mlange-42/arche/generic\" 8) 9 10// Position component 11type Position struct { 12\tX float64 13\tY float64 14} 15 16// Velocity component 17type Velocity struct { 18\tX float64 19\tY float64 20} 21 22func main() { 23\t// Create a World. 24\tworld := ecs.NewWorld() 25 26\t// Create a component mapper. 27\tmapper := generic.NewMap2[Position, Velocity](\u0026world) 28 29\t// Create entities. 30\tfor i := 0; i \u003c 1000; i++ { 31\t// Create a new Entity with components. 32\tentity := mapper.New() 33\t// Get the components 34\tpos, vel := mapper.Get(entity) 35\t// Initialize component fields. 36\tpos.X = rand.Float64() * 100 37\tpos.Y = rand.Float64() * 100 38\tvel.X = rand.NormFloat64() 39\tvel.Y = rand.NormFloat64() 40\t} 41 42\t// Create a generic filter. 43\tfilter := generic.NewFilter2[Position, Velocity]() 44 45\t// Time loop. 46\tfor t := 0; t \u003c 1000; t++ { 47\t// Get a fresh query. 48\tquery := filter.Query(\u0026world) 49\t// Iterate it 50\tfor query.Next() { 51\t// Component access through the Query. 52\tpos, vel := query.Get() 53\t// Update component fields. 54\tpos.X += vel.X 55\tpos.Y += vel.Y 56\t} 57\t} 58} What’s next? If you ask “What is ECS?”, take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\nTo learn how to use Arche, read the User Guide, browse the API documentation, or take a look at the examples in the GitHub repository.\nYou can also read about Arche’s Design Philosophy and Architecture for more background information.\nSee the Benchmarks if you are interested in some numbers on Arche’s performance."},"title":"Quickstart"}}